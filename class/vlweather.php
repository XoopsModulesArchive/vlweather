<?php

/***********************************************************************************/
/*                                                                                 */
/* VLWeather version 0.1                                                           */
/* Adaptation based on work in phpweather and XP-Weather                           */
/* Nicholas Petreley, www.varlinux.org                                             */
/*                                                                                 */
/* When names have been changed from phpweather or XP-Weather to vlweather         */
/* it is not to usurp credit but to divert blame to my additions and changes. ;)   */
/*                                                                                 */
/***********************************************************************************/

/**
*
* The decoded METAR is saved in $decoded_metar, in a language-neutral
* format.
*
* @author   Martin Geisler <gimpster@gimpster.com>
* @version  phpweather.php,v 1.32 2002/09/02 18:17:47 gimpster Exp
* @package  PHP Weather
* @access   public
* @see	     $decoded_metar
*/
class vlweather {

	/**
	* Various properties such as icao, country, pref_units stored here
	*
	*/

	var $properties = array();

	/**
	* Verbosity of errors.  Default = 1;
	*
	*/

	var $verbosity = 1;


	/**
	* The METAR is stored here.
	*
	* The property is used whenever someone wants access to the raw
	* METAR. This should be used for reading only, if you want to
	* change the METAR (for testing purposes etc.), then use
	* set_metar() instead.
	*
	* @var string
	* @see set_metar()
	*/
	var $metar;
	// previous metar
	var $pmetar;

	/**
	* Data associated with the current ICAO.
	*
	* @var  array  The array has three entries: name, country,
	*              and country code of the ICAO.
	*/
	var $icao_data;

	/**
	* The decoded METAR is stored here.
	*
	* $decoded_metar is an array of arrays. Each sub-array corresponds
	* to a group of related weather-info. We have cloud-groups,
	* visibility-groups and so on.
	*
	* @var  array
	*/
	var $decoded_metar;
	// previous metar
	var $decoded_pmetar;

	/**
	* The METAR is interpreted into an HTML block for display.
	*
	* @var  array
	*/
	var $imblock;

	// =======================================================================
	// This section contains user configurable items: The user can
	// configure the image filenames to be generated by the script.

	// An array to convert the weather group codes to an index of the
	// $images and $n_images array.

	var $phenomena_array = array ('#'  => 'None',
	                              'TS' => 'Thun',
	                              'RA' => 'Rain',
	                              'DZ' => 'Rain',
	                              'SN' => 'Snow',
	                              'SG' => 'Snow',
	                              'GR' => 'Hail',
	                              'GS' => 'Hail',
	                              'PE' => 'Hail',
	                              'PL' => 'Hail',
	                              'IC' => 'Hail',
	                              'BR' => 'Fog',
	                              'FG' => 'Fog');

	// An array to convert the cloud coverage codes to an index of the
	// $images and $n_images array.

	var $coverage = array ('CLR' => '0',
	                       'SKC' => '0',
	                       'FEW' => '1',
	                       'SCT' => '2',
	                       'BKN' => '3',
	                       'OVC' => '4',
	                       'VV'  => '4');

	var $sky_nodata_image = 'sky_nodata.gif';

	// Define a lot of images for daylight weather-group/cloud
	// condition. It's a 2-dimensional array, indexed by the:
	// - Precipitation (first index)
	// - Cloud coverage (second index).

	var $images = array ('None'  => array ('0' => '0cloud.gif',
	                                       '1' => '1cloud_norain.gif',
	                                       '2' => '2cloud_norain.gif',
	                                       '3' => '3cloud_norain.gif',
	                                       '4' => '4cloud_norain.gif'),
	                     '-Rain' => array ('0' => '0cloud.gif',
	                                       '1' => '1cloud_lightrain.gif',
	                                       '2' => '2cloud_lightrain.gif',
	                                       '3' => '3cloud_lightrain.gif',
	                                       '4' => '4cloud_lightrain.gif'),
	                     'Rain'  => array ('0' => '0cloud.gif',
	                                       '1' => '1cloud_modrain.gif',
	                                       '2' => '2cloud_modrain.gif',
	                                       '3' => '3cloud_modrain.gif',
	                                       '4' => '4cloud_modrain.gif'),
	                     '+Rain' => array ('0' => '0cloud.gif',
	                                       '1' => '1cloud_heavyrain.gif',
	                                       '2' => '2cloud_heavyrain.gif',
	                                       '3' => '3cloud_heavyrain.gif',
	                                       '4' => '4cloud_heavyrain.gif'),
	                     '-Snow' => array ('0' => '0cloud.gif',
	                                       '1' => '2cloud_snow.gif',
	                                       '2' => '2cloud_snow.gif',
	                                       '3' => '3cloud_snow.gif',
	                                       '4' => '4cloud_lightsnow.gif'),
	                     '+Snow' => array ('0' => '0cloud.gif',
	                                       '1' => '2cloud_snow.gif',
	                                       '2' => '2cloud_snow.gif',
	                                       '3' => '3cloud_snow.gif',
	                                       '4' => '4cloud_heavysnow.gif'),
	                     '-Hail' => array ('0' => '0cloud.gif',
	                                       '1' => '2cloud_hail.gif',
	                                       '2' => '2cloud_hail.gif',
	                                       '3' => '3cloud_hail.gif',
	                                       '4' => '4cloud_lighthail.gif'),
	                     '+Hail' => array ('0' => '0cloud.gif',
	                                       '1' => '2cloud_hail.gif',
	                                       '2' => '2cloud_hail.gif',
	                                       '3' => '3cloud_hail.gif',
	                                       '4' => '4cloud_heavyhail.gif'),
	                     'Thun'  => array ('0' => '0cloud.gif',
	                                       '1' => '2cloud_thunders.gif',
	                                       '2' => '2cloud_thunders.gif',
	                                       '3' => '3cloud_thunders.gif',
	                                       '4' => '4cloud_thunders.gif'),
	                     'Fog'   => array ('0' => '0cloud_fog.gif',
	                                       '1' => '1cloud_fog.gif',
	                                       '2' => '2cloud_fog.gif',
	                                       '3' => '3cloud_fog.gif',
	                                       '4' => '4cloud_fog.gif')
	                    );

	// Define a lot of images for nigh time weather-group/cloud
	// condition. It has the same structure as the daylight array
	// $images It's a 2-dimensional array, indexed by the:
	// - Precipitation (first index)
	// - Cloud coverage (second index).

	var $n_images = array (
	                        'None'   => array ('0' => 'n_0cloud.gif',
	                                           '1' => 'n_1cloud_norain.gif',
	                                           '2' => 'n_2cloud_norain.gif',
	                                           '3' => 'n_3cloud_norain.gif',
	                                           '4' => '4cloud_norain.gif'),
	                        '-Rain'  => array ('0' => 'n_0cloud.gif',
	                                           '1' => 'n_1cloud_lightrain.gif',
	                                           '2' => 'n_2cloud_lightrain.gif',
	                                           '3' => 'n_3cloud_lightrain.gif',
	                                           '4' => '4cloud_lightrain.gif'),
	                        'Rain'   => array ('0' => 'n_0cloud.gif',
	                                           '1' => 'n_1cloud_modrain.gif',
	                                           '2' => 'n_2cloud_modrain.gif',
	                                           '3' => 'n_3cloud_modrain.gif',
	                                           '4' => '4cloud_modrain.gif'),
	                        '+Rain'  => array ('0' => 'n_0cloud.gif',
	                                           '1' => 'n_1cloud_heavyrain.gif',
	                                           '2' => 'n_2cloud_heavyrain.gif',
	                                           '3' => 'n_3cloud_heavyrain.gif',
	                                           '4' => '4cloud_heavyrain.gif'),
	                        '-Snow'  => array ('0' => 'n_0cloud.gif',
	                                           '1' => 'n_2cloud_snow.gif',
	                                           '2' => 'n_2cloud_snow.gif',
	                                           '3' => 'n_3cloud_snow.gif',
	                                           '4' => '4cloud_lightsnow.gif'),
	                        '+Snow'  => array ('0' => 'n_0cloud.gif',
	                                           '1' => 'n_2cloud_snow.gif',
	                                           '2' => 'n_2cloud_snow.gif',
	                                           '3' => 'n_3cloud_snow.gif',
	                                           '4' => '4cloud_heavysnow.gif'),
	                        '-Hail'  => array ('0' => 'n_0cloud.gif',
	                                           '1' => 'n_2cloud_hail.gif',
	                                           '2' => 'n_2cloud_hail.gif',
	                                           '3' => 'n_3cloud_hail.gif',
	                                           '4' => '4cloud_lighthail.gif'),
	                        '+Hail'  => array ('0' => 'n_0cloud.gif',
	                                           '1' => 'n_2cloud_hail.gif',
	                                           '2' => 'n_2cloud_hail.gif',
	                                           '3' => 'n_3cloud_hail.gif',
	                                           '4' => '4cloud_heavyhail.gif'),
	                        'Thun'   => array ('0' => 'n_0cloud.gif',
	                                           '1' => 'n_2cloud_thunders.gif',
	                                           '2' => 'n_2cloud_thunders.gif',
	                                           '3' => 'n_3cloud_thunders.gif',
	                                           '4' => '4cloud_thunders.gif'),
	                        'Fog'    => array ('0' => 'n_0cloud_fog.gif',
	                                           '1' => 'n_1cloud_fog.gif',
	                                           '2' => 'n_2cloud_fog.gif',
	                                           '3' => 'n_3cloud_fog.gif',
	                                           '4' => '4cloud_fog.gif')
	                );

	var $vphenomena_array = array ('#'  => 'None',
	                               'TS' => 'Thun',
	                               'SH' => 'Show',
	                               'RA' => 'Rain',
	                               'DZ' => 'Rain',
	                               'GR' => 'Rain',
	                               'SN' => 'Snow',
	                               'SG' => 'Snow',
	                               'GS' => 'Snow',
	                               'PE' => 'Snow',
	                               'PL' => 'Snow',
	                               'IC' => 'Snow',
	                               'BR' => 'Fog',
	                               'FG' => 'Fog');

	// An array to convert the cloud coverage codes to an index of the
	// $images and $n_images array.

	var $vcoverage = array ('CLR' => '0',
	                        'SKC' => '0',
	                        'FEW' => '1',
	                        'SCT' => '2',
	                        'BKN' => '3',
	                        'OVC' => '4',
	                        'VV'  => '4');

	var $vsky_nodata_image = 'sky_nodata.gif';

	// Define a lot of images for daylight weather-group/cloud
	// condition. It's a 2-dimensional array, indexed by the:
	// - Precipitation (first index)
	// - Cloud coverage (second index).

	var $vimages = array ('None'  => array ('0' => '0cloud.gif',
	                                        '1' => '1cloud_norain.gif',
	                                        '2' => '2cloud_norain.gif',
	                                        '3' => '3cloud_norain.gif',
	                                        '4' => '4cloud_norain.gif'),
	                      '-Rain' => array ('0' => '0cloud.gif',
	                                        '1' => '1cloud_lightrain.gif',
	                                        '2' => '2cloud_lightrain.gif',
	                                        '3' => '3cloud_lightrain.gif',
	                                        '4' => '4cloud_lightrain.gif'),
	                      'Rain'  => array ('0' => '0cloud.gif',
	                                        '1' => '1cloud_modrain.gif',
	                                        '2' => '2cloud_modrain.gif',
	                                        '3' => '3cloud_modrain.gif',
	                                        '4' => '4cloud_modrain.gif'),
	                      '+Rain' => array ('0' => '0cloud.gif',
	                                        '1' => '1cloud_heavyrain.gif',
	                                        '2' => '2cloud_heavyrain.gif',
	                                        '3' => '3cloud_heavyrain.gif',
	                                        '4' => '4cloud_heavyrain.gif'),
	                      '-Snow' => array ('0' => '0cloud.gif',
	                                        '1' => '2cloud_snow.gif',
	                                        '2' => '2cloud_snow.gif',
	                                        '3' => '3cloud_snow.gif',
	                                        '4' => '4cloud_lightsnow.gif'),
	                      '+Snow' => array ('0' => '0cloud.gif',
	                                        '1' => '2cloud_snow.gif',
	                                        '2' => '2cloud_snow.gif',
	                                        '3' => '3cloud_snow.gif',
	                                        '4' => '4cloud_heavysnow.gif'),
	                      '-Hail' => array ('0' => '0cloud.gif',
	                                        '1' => '2cloud_hail.gif',
	                                        '2' => '2cloud_hail.gif',
	                                        '3' => '3cloud_hail.gif',
	                                        '4' => '4cloud_lighthail.gif'),
	                      '+Hail' => array ('0' => '0cloud.gif',
	                                        '1' => '2cloud_hail.gif',
	                                        '2' => '2cloud_hail.gif',
	                                        '3' => '3cloud_hail.gif',
	                                        '4' => '4cloud_heavyhail.gif'),
	                      'Thun'  => array ('0' => '0cloud.gif',
	                                        '1' => '2cloud_thunders.gif',
	                                        '2' => '2cloud_thunders.gif',
	                                        '3' => '3cloud_thunders.gif',
	                                        '4' => '4cloud_thunders.gif'),
	                      'Fog'   => array ('0' => '0cloud_fog.gif',
	                                        '1' => '1cloud_fog.gif',
	                                        '2' => '2cloud_fog.gif',
	                                        '3' => '3cloud_fog.gif',
	                                        '4' => '4cloud_fog.gif')
	                     );

	// Define a lot of images for nigh time weather-group/cloud
	// condition. It has the same structure as the daylight array
	// $images It's a 2-dimensional array, indexed by the:
	// - Precipitation (first index)
	// - Cloud coverage (second index).

	var $vn_images = array (
	                         'None'   => array ('0' => 'n_0cloud.gif',
	                                            '1' => 'n_1cloud_norain.gif',
	                                            '2' => 'n_2cloud_norain.gif',
	                                            '3' => 'n_3cloud_norain.gif',
	                                            '4' => '4cloud_norain.gif'),
	                         '-Rain'  => array ('0' => 'n_0cloud.gif',
	                                            '1' => 'n_1cloud_lightrain.gif',
	                                            '2' => 'n_2cloud_lightrain.gif',
	                                            '3' => 'n_3cloud_lightrain.gif',
	                                            '4' => '4cloud_lightrain.gif'),
	                         'Rain'   => array ('0' => 'n_0cloud.gif',
	                                            '1' => 'n_1cloud_modrain.gif',
	                                            '2' => 'n_2cloud_modrain.gif',
	                                            '3' => 'n_3cloud_modrain.gif',
	                                            '4' => '4cloud_modrain.gif'),
	                         '+Rain'  => array ('0' => 'n_0cloud.gif',
	                                            '1' => 'n_1cloud_heavyrain.gif',
	                                            '2' => 'n_2cloud_heavyrain.gif',
	                                            '3' => 'n_3cloud_heavyrain.gif',
	                                            '4' => '4cloud_heavyrain.gif'),
	                         '-Snow'  => array ('0' => 'n_0cloud.gif',
	                                            '1' => 'n_2cloud_snow.gif',
	                                            '2' => 'n_2cloud_snow.gif',
	                                            '3' => 'n_3cloud_snow.gif',
	                                            '4' => '4cloud_lightsnow.gif'),
	                         '+Snow'  => array ('0' => 'n_0cloud.gif',
	                                            '1' => 'n_2cloud_snow.gif',
	                                            '2' => 'n_2cloud_snow.gif',
	                                            '3' => 'n_3cloud_snow.gif',
	                                            '4' => '4cloud_heavysnow.gif'),
	                         '-Hail'  => array ('0' => 'n_0cloud.gif',
	                                            '1' => 'n_2cloud_hail.gif',
	                                            '2' => 'n_2cloud_hail.gif',
	                                            '3' => 'n_3cloud_hail.gif',
	                                            '4' => '4cloud_lighthail.gif'),
	                         '+Hail'  => array ('0' => 'n_0cloud.gif',
	                                            '1' => 'n_2cloud_hail.gif',
	                                            '2' => 'n_2cloud_hail.gif',
	                                            '3' => 'n_3cloud_hail.gif',
	                                            '4' => '4cloud_heavyhail.gif'),
	                         'Thun'   => array ('0' => 'n_0cloud.gif',
	                                            '1' => 'n_2cloud_thunders.gif',
	                                            '2' => 'n_2cloud_thunders.gif',
	                                            '3' => 'n_3cloud_thunders.gif',
	                                            '4' => '4cloud_thunders.gif'),
	                         'Fog'    => array ('0' => 'n_0cloud_fog.gif',
	                                            '1' => 'n_1cloud_fog.gif',
	                                            '2' => 'n_2cloud_fog.gif',
	                                            '3' => 'n_3cloud_fog.gif',
	                                            '4' => '4cloud_fog.gif')
	                 );

	// Define image filenames for:
	// - 16 wind directions,
	// - 'no wind direction data'
	// - variable wind direction (VRB)
	// - calm wind (00000KT), or 'nodir'

	var $wind_dir_images = array (0 => 'nnn.gif',
	                              1 => 'nne.gif',
	                              2 => 'ne.gif',
	                              3 => 'nee.gif',
	                              4 => 'eee.gif',
	                              5 => 'see.gif',
	                              6 => 'se.gif',
	                              7 => 'sse.gif',
	                              8 => 'sss.gif',
	                              9 => 'ssw.gif',
	                              10 => 'sw.gif',
	                              11 => 'sww.gif',
	                              12 => 'www.gif',
	                              13 => 'nww.gif',
	                              14 => 'nw.gif',
	                              15 => 'nnw.gif',
	                              16 => 'nnn.gif');

	var $wind_nodata_image = 'wind_nodata.gif';
	var $wind_vrb_image = 'vrb.gif';
	var $wind_nodir_image = 'nodir.gif';

	// Define image filenames for:
	// - 'no data' condition,
	// - 'temperature zero or below zero degrees Celcius
	// - 'temperature above zero degrees Celcius

	var $temp_nodata_image = 'temp_nodata.gif';
	var $temp_low_image  = 'templow.gif';
	var $temp_high_image = 'temphigh.gif';
	var $temp_windchilled_image = 'tempchilled.gif';
	// ======================================================================

	// The wind_speeds array can be used to convert wind speed values in
	// [m/s] to [Bft] (beaufort).

	var $wind_speeds = array (
	                           'beaufort' => array (0,    1,    2,    3,    4,    5,
	                                                6,    7,    8,    9,    10,   11,   12),
	                           'ms'       => array (0.3,  1.6,  3.4,  5.5,  8.0,  10.8,
	                                                13.9, 17.2, 20.8, 24.5, 28.5, 32.7, 999));
	// ------------------------------------------------------------------------


	/**
	* This constructor does nothing besides passing the input down the
	* hierarchy.
	*
	* @param	array	The initial properties of the object.
	*/
	function vlweather($input = array()) {
		// set defaults
		$this->properties['verbosity']     = 1;             /* base_object.php */
		$this->properties['always_use_db'] = false;         /* data_retrieval.php */
		$this->properties['cache_timeout'] = 1200;
		$this->properties['use_proxy']     = false;
		$this->properties['proxy_host']    = '';
		$this->properties['proxy_port']    = 3128;
		$this->properties['fetch_method']  = 'fsockopen';
		$this->properties['mark_begin']    = '<b>';
		$this->properties['mark_end']      = '</b>';
		$this->properties['exclude']       = array();
		$this->properties['orientation']   = 'horizontal';  /* pw_text.php */
		$this->properties['icons_path']    = 'icons/';      /* pw_images.php */
		$this->properties['offset']        = 0;             /* phpweather.php */

		/* If everything works right, these next settings will never be used */
		/* The defaults from cache/config.php will replace them */

		$this->properties['icao'] = 'KORD';
		$this->properties['timeoffset'] = -6.0;
		$this->properties['pref_units'] = 'both_imperial';

		/* And here's where it should happen  (the array passed to this constructor has the data) */

		while (list($key, $value) = each($input)) {
			$this->properties[$key] = $value;
		}
	}

	/**
	* Returns the current ICAO.
	*
	* @access	public
	* @return	string	 The ICAO of the current station.
	*/
	function get_icao() {
		return $this->properties['icao'];
	}

	/**
	* Sets the station or rather the ICAO.
	*
	* It also clears the METAR and the decoded METAR data if the ICAO
	* is different from the old one. If the new ICAO is the same as the
	* old one, nothing is changed.
	*
	* @access	public
	* @param	string   The ICAO of the new station.
	*/
	function set_icao($new_icao) {

		/* We start by adding slashes, since $new_icao might come directly
		* from the user.
		*/
		$new_icao = addslashes($new_icao);
		if ($new_icao != $this->get_icao()) {
			$this->properties['icao'] = strtoupper($new_icao);
			$this->icao_data = false;
			$this->metar = false;
			$this->decoded_metar = false;
		}
	}


	/**
	* Sets the time offset for the station
	*
	* @access	public
	* @param	string   The ICAO of the new station.
	*/
	function set_timeoffset($timeoffset) {
		$this->properties['timeoffset'] = $timeoffset;
	}

	/**
	* Gets the time offset for the station
	*
	* @access	public
	* @param	string   The ICAO of the new station.
	*/
	function get_timeoffset() {
		return($this->properties['timeoffset']);
	}


	/**
	* Sets the format (metric, imperial, etc.)
	*
	* @access	public
	* @param	string   The ICAO of the new station.
	*/
	function set_format($prefunits) {
		$this->properties['pref_units'] = strtolower($prefunits);
	}

	/**
	* Gets the format.
	*
	* @access	public
	* @param	string   The ICAO of the new station.
	*/
	function get_format() {
		return($this->properties['pref_units']);
	}


	/**
	* Retrieves a raw METAR, either from the web or from a database.
	*
	* If the METAR is already set, then it just returns that. If it's
	* not set, then it tries to get it from the database.
	*
	* @access	public
	* @return	string   The raw METAR.
	*/
	function get_metar() {
		if (empty($this->metar)) {
			/* The METAR is not set - we try to load it */
			$this->debug('The METAR is not set, I\'ll try to find the METAR in the database.');
			$this->metar = $this->get_metar_from_db();
			return $this->metar;
		} else {
			$this->debug('The METAR was set - I\'ll just use that.');
			return $this->metar;
		}
	}

	/**
	* Retrieves the raw previous METAR, if it exists
	* and creates one if it doesn't
	*
	* @access	public
	* @return	string   The raw METAR.
	*/
	function get_pmetar() {
		global $xoopsDB;
		$icao = $this->get_icao();
		if (!empty($icao)) {
			$sql = 'SELECT metar, UNIX_TIMESTAMP(timestamp) from ' . $xoopsDB->prefix("pmetars") . ' WHERE icao="' . $icao .'"';
			$result=$xoopsDB->query($sql);
			if ($xoopsDB->getRowsNum($result)) {
				list($pmetar, $ptimestamp)=$xoopsDB->fetchRow($result);
				$sql = 'SELECT metar, UNIX_TIMESTAMP(timestamp) from ' . $xoopsDB->prefix("metars") . ' WHERE icao="' . $icao .'"';
				$result=$xoopsDB->query($sql);
				list($metar,$timestamp)=$xoopsDB->fetchRow($result);
				$difftime = $timestamp - $ptimestamp;
				if ($difftime <= 9000) {
				    $this->pmetar = $pmetar;
				} else {
				    $this->pmetar = $metar;
//				    $this->update_metar($icao, $metar, $timestamp);
				}
				return $this->pmetar;
			} else {
				$this->pmetar = $this->metar;
				return $this->pmetar;
			}
		} else {
			$this->pmetar = '';
			return $this->pmetar;
		}
	}

	/**
	* Sets the METAR directly, for testing etc
	*
	* It loads and decodes the METAR if it is different from the old
	* one. If the new METAR is the same as the old one, nothing is
	* changed.
	*
	* Also sets the ICAO to be correct for this METAR.
	*
	* @access	public
	* @param	string   The METAR we want decoded.
	*/
	function set_metar($new_metar) {

		if ($new_metar != $this->get_metar()) {
			$this->debug('Loading a METAR manually.');
			$this->properties['icao'] = strtoupper(substr($new_metar,0,4));
			$this->icao_data = $this->lookup_icao($this->get_icao());
			$this->metar = $new_metar;
		}
	}


	function get_metar_socket($icao) {
		$host = 'weather.noaa.gov';
		$location = "/pub/data/observations/metar/stations/$icao.TXT";
		$request = "HTTP/1.1\r\n" .
		           "If-Modified-Since: Sat, 29 Oct 1994 09:00:00 GMT\r\n" .
		           "Pragma: no-cache\r\n".
		           "Cache-Control: no-cache\r\n";

		if ($this->properties['use_proxy']) {
			/* We use a proxy */
			$fp = fsockopen($this->properties['proxy_host'],
			                $this->properties['proxy_port']);
			$request = "GET http://$host$location $request" .
			           "Host: $host\r\n" .
			           "Content-Type: text/html\r\n" .
			           "Connection: Close\r\n\r\n";
		} else {
			$fp = fsockopen($host, 80);
			$request = "GET $location $request" .
			           "Host: $host\r\n" .
			           "Content-Type: text/html\r\n" .
			           "Connection: Close\r\n\r\n";
		}

		$metar_data = false;

		if ($fp) {
			fputs($fp, $request);
			/* We check the status line */
			if (strpos(fgets($fp, 1024), '200 ')) {
				/* Then we seek until we find the empty line between the
				* headers and the contents.
				*/
				do {
					$line = fgets($fp, 1024);
				} while ($line != "\r\n");

				/* We know now, that the following lines are the contents. */
				while ($line = fgets($fp, 1024)) {
					$metar_data[] = $line;
				}
				fclose($fp);
			}
		}

		return $metar_data;
	}


	function get_metar_file($icao) {
		$host = 'weather.noaa.gov';
		$location = "/pub/data/observations/metar/stations/$icao.TXT";
		return @file('http://' . $host . $location);
	}


	/**
	* Tries to get a METAR from the database.
	*
	* It looks in the database, and fetches a new METAR if necessary.
	* You do not have to be connected to the database before you call
	* this function, just make sure that you have passed the right
	* properties to the object.
	*
	* If $this->properties['always_use_db'] is True, then it ignores
	* the timestamp of the METAR and just returns it. Otherwise it will
	* try to get a new METAR from the web, if the old one is older than
	* one hour.
	*
	* @access	public
	* @return	string   The raw METAR.
	*/
	function get_metar_from_db() {
		global $xoopsDB;

		$sql = sprintf('SELECT metar, UNIX_TIMESTAMP(timestamp) FROM '. $xoopsDB->prefix("metars") . ' WHERE icao = "%s"', $this->properties['icao']);
		$result = $xoopsDB->query($sql);
		if ($xoopsDB->getRowsNum($result)) {
			list($metar, $timestamp) = $xoopsDB->fetchRow($result);
			$this->debug('get_metar_from_db(): Found the METAR in the database');

			/* We set the METAR right away, and then count on
			* get_metar_from_web() to set it to something else, if
			* necessary.
			*/
			$this->metar = $metar;
			if ($this->properties['always_use_db'] || ($timestamp > (time() - $this->properties['cache_timeout']))) {
				/* We have asked explicit for a cached METAR, or the METAR is
				* still fresh. Either way - we return the METAR we found in
				* the database.
				*/
				$this->debug('get_metar_from_db(): Using previously cached METAR for <code>' .
				             $this->get_location() . '</code>. The METAR expires in ' .
				             ($timestamp + $this->properties['cache_timeout'] - time()) .
				             ' seconds.');
				return $metar;
			} else {
				/* The METAR is too old, so we fetch new */
				$this->debug('get_metar_from_db(): The METAR for <code>' .
				             $this->get_location() . '</code> was ' .
				             (time() - $this->properties['cache_timeout'] - $timestamp) .
				             ' seconds too old.');
				return $this->get_metar_from_web(false);
			}
		} else {
			/* We need to get a new METAR from the web. */
			$this->debug('get_metar_from_db(): New station <code>' .
			             $this->get_location() . '</code> - fetching a new METAR.');
			return $this->get_metar_from_web(true);
		}
	}


	/**
	* Fetches a METAR from the Internet.
	*
	* The METAR is fetched via HTTP from the National Weather Services
	* public server. The files can be found under the
	* http://weather.noaa.gov/pub/data/observations/metar/stations/
	* directory as ICAO.TXT where ICAO is replaced by the actual ICAO.
	*
	* @param boolean   Should the station be inserted into the database,
	* or should we update an already existing entry?
	* @access	public
	* @return	string   The raw METAR.
	*/
	function get_metar_from_web($new_station) {

		$metar = '';
		$icao = $this->get_icao();

		switch ($this->properties['fetch_method']) {
		case 'file':
   		$metar_data = $this->get_metar_file($icao);
			break;
		case 'fsockopen':
		default:
			$metar_data = $this->get_metar_socket($icao);
			break;
		}

		/* Here we test to see if we actually got a METAR. */
		if (!empty($metar_data)) {
			/* The first line in the file is the date */
			$date = trim(array_shift($metar_data));
			/* The remaining lines are the METAR itself. This will merge the
			* remaining lines into one line by removing new-lines:
			*/
			$metar = ereg_replace("[\n\r ]+", ' ', trim(implode(' ', $metar_data)));

			$date = explode(':', strtr($date, '/ ', '::'));
			if ($date[2] > gmdate('j')) {
				/* The day is greater that the current day of month. This
				* implies, that the report is from last month.
				*/
				$date[1]--;
			}
			$timestamp = gmmktime($date[3], $date[4], 0,
			                      $date[1], $date[2], $date[0]);

			if (!ereg('[0-9]{6}Z', $metar)) {
				/* Some reports don't even have a time-part, so we insert the
				* current time. This might not be the time of the report, but
				* it was broken anyway :-)
				*/
				$metar = gmdate('dHi', $timestamp) . 'Z ' . $metar;
			}

//			if ($timestamp < (time() - $this->properties['cache_timeout'] + 300)) {
				/* The timestamp in the METAR is more than XX minutes old 
				* (determined by cache_timeout). We
				* adjust the timestamp, so that we won't try to fetch a new
				* METAR within the next 5 minutes. After 5 minutes, the
				* timestamp will again be more than 1 hour old.
				*/
//				$timestamp = time() - $this->properties['cache_timeout'] + 300;
//			}
		} else {
			/* If we end up here, it means that there was no file. If the
			* station was a new station, we set the metar to an empty
			* string, else we just use the old METAR. We adjust the time
			* stored in the database in both cases, so that the server
			* isn't stressed too much.
			*/
			if ($new_station) {
				$metar = '';
			} else {
				$metar = $this->metar;
			}
			$timestamp = time() - $this->properties['cache_timeout'] + 600;
		}

		/* We then cache the METAR in our database */
		if ($new_station && isset($icao) && ! empty($icao)) {
			$this->debug('get_metar_from_web(): Inserting new METAR for <code>' .
			             $this->get_location() . '</code>');
			$this->insert_metar($icao, $metar, $timestamp);
		} else {
			$this->debug('get_metar_from_web(): Updating METAR for <code>' .
			             $this->get_location() . '</code>');
			$this->update_metar($icao, $metar, $timestamp);
		}
		/* We update and return the METAR */
		$this->metar = $metar;

		return $metar;
	}

	/**
	* Inserts a METAR into the database.
	*
	* @param   string   The ICAO of the station.
	* @param   string   The raw METAR.
	* @param   integer  A standard UNIX timestamp.
	* @access  public
	* @see update_metar()
	*/
	function insert_metar($icao, $metar, $timestamp) {
		global $xoopsDB;
		$msql = sprintf('INSERT INTO ' . $xoopsDB->prefix("metars") . ' SET icao = "%s", metar = "%s", timestamp = FROM_UNIXTIME(%d)', $icao, addslashes($metar), intval($timestamp));
		$mresult = $xoopsDB->queryF($msql);
		$msuccess = $xoopsDB->getRowsNum($mresult);
		
		$psql = sprintf('INSERT INTO ' . $xoopsDB->prefix("pmetars") . ' SET icao = "%s", metar = "%s", timestamp = FROM_UNIXTIME(%d)', $icao, addslashes($metar), intval($timestamp));
		$presult = $xoopsDB->queryF($psql);
		$psuccess = $xoopsDB->getRowsNum($presult);
		
		if ($msuccess && $psuccess) {
			return true;
		} else {
			return false;
		}
	}


	/**
	* Updates an existing METAR in the database.
	*
	* @param   string   The ICAO of the station.
	* @param   string   The raw METAR.
	* @param   integer  A standard UNIX timestamp.
	* @access  public
	* @see insert_metar()
	*/
	function update_metar($icao, $metar, $timestamp) {
		global $xoopsDB;

		// Get old data and timestamp
		$msql = "SELECT metar, UNIX_TIMESTAMP(timestamp) from " . $xoopsDB->prefix("metars") . " WHERE icao='" . $icao . "'";
		$mresult = $xoopsDB->query($msql);
		$numrows = $xoopsDB->getRowsNum($mresult);
		if ($numrows) {
     		list ($oldmetar, $oldtimestamp) = $xoopsDB->fetchRow($mresult);
 			$difftime = $timestamp - $oldtimestamp;
 			
 			// if they're different timestamps, update the previous metar
 			if ($difftime) {
        		// Put new data into metar table
        		$msql = sprintf('UPDATE ' . $xoopsDB->prefix("metars") . ' SET metar = "%s", timestamp = FROM_UNIXTIME(%d) WHERE icao = "%s"', addslashes($metar), intval($timestamp), $icao);
        		$xoopsDB->queryF($msql);

            // Look at the previous metar, see if it needs updating, too        		
       		$psql = "SELECT metar, UNIX_TIMESTAMP(timestamp) from " . $xoopsDB->prefix("pmetars") . " WHERE icao='" . $icao . "'";
       		$presult = $xoopsDB->query($psql);
       		$pnumrows = $xoopsDB->getRowsNum($presult);
       		
   			// if there's a previous metar stored already, check the difference in time
       		if ($pnumrows) {
           		list ($pmetar, $ptimestamp) = $xoopsDB->fetchRow($result);
           		$difftime = $oldtimestamp - $ptimestamp;
           		if ($difftime) {
        				$psql = sprintf('UPDATE ' . $xoopsDB->prefix("pmetars") . ' SET metar = "%s", timestamp = FROM_UNIXTIME(%d) WHERE icao = "%s"', addslashes($oldmetar), intval($oldtimestamp), $icao);
     	   			$xoopsDB->queryF($psql);
     	   		}
       		} else {
       		   // There should always be a pmetar, since it's added automatically
       		   // when the metar is added, so repair the table if there isn't one
       		   // because the lack of one means it got corrupted
       			$psql = 'repair table ' . $xoopsDB->prefix("pmetars");
       			$xoopsDB->queryF($psql);
       			
       			// insert the current metar into the pmetar (previous metar) table
       			$sql = sprintf('INSERT INTO ' . $xoopsDB->prefix("pmetars") . ' (metar, timestamp, icao) VALUES("%s", FROM_UNIXTIME(%d), "%s")', addslashes($oldmetar), intval($oldtimestamp), $icao);
       			$xoopsDB->queryF($sql);
       		}
         }
     	} else {
 			// save the current metar into the pmetar (previous metar) table
 			$msql = sprintf('INSERT INTO ' . $xoopsDB->prefix("metars") . ' (metar, timestamp, icao) VALUES("%s", FROM_UNIXTIME(%d), "%s")', addslashes($metar), intval($timestamp), $icao);
 			$mresult = $xoopsDB->queryF($msql);
 			if (!$mresult) {
     			$msql = 'repair table ' . $xoopsDB->prefix("metars");
     			$xoopsDB->queryF($msql);
 			}
  	   }
	}


	/**
	* Gets a METAR from the database.
	*
	* @param   string  The ICAO of the station.
	* @return  string  The raw METAR as an array from the database.
	* @access  public
	*/
	function get_metar_row($icao) {
		global $xoopsDB;

		$sql = sprintf('SELECT metar, UNIX_TIMESTAMP(timestamp) FROM '. $xoopsDB->prefix("metars") . ' WHERE icao = "%s"', $icao);
		$result = $xoopsDB->query($sql);
		return $xoopsDB->fetchRow($result);
	}


	/**
	* Fetches information about an ICAO.
	*
	* The array returned contains three entries: the name of the
	* station, the name of the country, the country code of the
	* country.
	*
	* @param   string  The ICAO one want's to translate.
	* @return  array  Information about the ICAO or false if no
	*                 information is available.
	* @access  public
	*/
	function lookup_icao($icao) {
		global $xoopsDB;

		$result = $xoopsDB->query(sprintf('SELECT name, country, cc, locshort, zone FROM ' . $xoopsDB->prefix("stations") . '  WHERE icao = "%s"', addslashes($icao)));
		if ($xoopsDB->getRowsNum($result) == 1) {
			return $xoopsDB->fetchRow($result);
		} else {
			return false;
		}
	}

	/**
	* Returns a list of available countries.
	*
	* @return array An associative array with the country-codes as the
	* keys and the names of the countries as the values.
	* @access  public
	*/
	function get_countries() {
		global $xoopsDB;

		$result = $xoopsDB->query('SELECT DISTINCT cc, country FROM ' . $xoopsDB->prefix("stations") . ' ORDER BY country');
		while($row = $xoopsDB->fetchRow($result)) {
			$rows[$row[0]] = $row[1];
		}
		return $rows;
	}


	/**
	* Returns an array of stations.
	*
	* @param  string  The country-code.
	* @param  string  This parameter is passed by reference. The name of
	*                 the country that corresponds to the country-code
	*                 is stored here.
	* @return array   An associative array with the ICAO as the key and
	*                 the name of the station as the values. The name
	*                 of the country is not added to the name of the
	*                 station.
	* @access  public
	*/
	function get_icaos($cc, &$country) {
		global $xoopsDB;

		$result = $xoopsDB->query(sprintf('SELECT icao, name, country FROM ' . $xoopsDB->prefix("stations") . ' WHERE cc = "%s" ORDER BY name', addslashes($cc)));
		/* We have to do this manually the first time, so that we can set
		$country */
		list($icao, $name, $country) = $xoopsDB->fetchRow($result);
		$rows[$icao] = $name;
		while(list($icao, $name) = $xoopsDB->fetchRow($result)) {
			$rows[$icao] = $name;
		}
		return $rows;
	}

	/**
	* Returns the location of the current station.
	*
	* The location is the name of the station followed by the name of
	* the country. If the ICAO cannot be found in the database, then
	* the ICAO is just returned again.
	*
	* @return  string  The location of the station.
	*/
	function get_location() {
		if (!empty($this->icao_data)) {
			$location = $this->icao_data[0] . ', ' . $this->icao_data[1];
			$this->debug("get_location(): Using old location: $location");
			return $location;
		} else {
			$this->debug('get_location(): Looking for location in the database');
			$this->icao_data = $this->lookup_icao($this->get_icao());
			if (empty($this->icao_data)) {
				return $this->get_icao(); // ICAO not found in database.
			}
			else {
				return $this->icao_data[0] . ', ' . $this->icao_data[1];
			}
		}
	}


	function get_first_location() {
		if (!empty($this->icao_data)) {
			$location = $this->icao_data[3];
			if (empty($location)) {
				$location = $this->icao_data[0];
			}
			$this->debug("get_location(): Using old location: $location");
			return $location;
		} else {
			$this->debug('get_location(): Looking for location in the database');
			$this->icao_data = $this->lookup_icao($this->get_icao());
			if (empty($this->icao_data)) {
				return $this->get_icao(); // ICAO not found in database.
			}
			else {
				$location = $this->icao_data[3];
				if (empty($location)) {
					$location = $this->icao_data[0];
				}
				return $location;
			}
		}
	}


	function get_forecast_link() {
		if (!empty($this->icao_data)) {
			$zone = $this->icao_data[4];
			if (empty($zone)) {
				return $zone;
			} else {
				$location=$this->icao_data[3];
				$zonelink = "<a href='http://www.srh.noaa.gov/data/forecasts/" . $zone . ".php?&city=" . $location ."'>" . _VL_BL_VIEWFORE . "</a>";
				return $zonelink;
			}
		} else {
			$this->icao_data = $this->lookup_icao($this->get_icao());
			if (empty($this->icao_data)) {
				$zone = '';
				return $zone;
			} else {
				$zone = $this->icao_data[4];
				if (empty($zone)) {
					return $zone;
				} else {
					$location=$this->icao_data[3];
					$zonelink = "<a href='http://www.srh.noaa.gov/data/forecasts/" . $zone . ".php?&city=" . $location ."'>" . _VL_BL_VIEWFORE . "</a>";
					return $zonelink;
				}
			}
		}
	}


	function get_forecast_url() {
		if (!empty($this->icao_data)) {
			$zone = $this->icao_data[4];
			if (empty($zone)) {
				return $zone;
			} else {
				$location=$this->icao_data[3];
				$zonelink = "http://www.srh.noaa.gov/data/forecasts/" . $zone . ".php?&city=" . $location ."";
				return $zonelink;
			}
		} else {
			$this->icao_data = $this->lookup_icao($this->get_icao());
			if (empty($this->icao_data)) {
				$zone = '';
				return $zone;
			} else {
				$zone = $this->icao_data[4];
				if (empty($zone)) {
					return $zone;
				} else {
					$location=$this->icao_data[3];
					$zonelink = "http://www.srh.noaa.gov/data/forecasts/" . $zone . ".php?&city=" . $location ."";
					return $zonelink;
				}
			}
		}
	}


	/**
	* Returns the name of the station for the current ICAO.
	*
	* @return  string  The name of the station or false if the ICAO
	*                  wasn't found in the database.
	* @access  public
	*/
	function get_name() {
		if (!empty($this->icao_data)) {
			$this->debug('get_name(): Using old station name: ' . $this->icao_data[0]);
			return $this->icao_data[0];
		} else {
			$this->debug('get_name(): Looking for station name in the database');
			$this->icao_data = $this->lookup_icao($this->get_icao());
			if (empty($this->icao_data)) {
				return false; // ICAO not found in database.
			}
			else {
				return $this->icao_data[0];
			}
		}
	}


	/**
	* Returns the name of the country for the current ICAO.
	*
	* @return  string  The name of the country or false if the ICAO
	*                  wasn't found in the database.
	* @access  public
	*/
	function get_country() {
		if (!empty($this->icao_data)) {
			$this->debug('get_country(): Using old country name: ' . $this->icao_data[1]);
			return $this->icao_data[1];
		} else {
			$this->debug('get_country(): Looking for country name in the database');
			$this->icao_data = $this->lookup_icao($this->get_icao());
			if (empty($this->icao_data)) {
				return false; // ICAO not found in database.
			}
			else {
				return $this->icao_data[1];
			}
		}
	}


	/**
	* Returns contry code specified ICAO.
	*
	* @return	string	country code (cc)
	* @author	Ondrej Jombik <nepto@pobox.sk>
	* @access	public
	*/
	function get_country_code() {
		if (!empty($this->icao_data)) {
			$this->debug('get_country_code(): Using old country code (cc): ' .
			             $this->icao_data[2]);
			return $this->icao_data[2];
		} else {
			$this->debug('get_country(): Looking for country code (cc) in the database');
			$this->icao_data = $this->lookup_icao($this->get_icao());
			if (empty($this->icao_data)) {
				return false; // ICAO not found in database.
			}
			else {
				return $this->icao_data[2];
			}
		}
	}


	/**
	* Helper-function used to store temperatures.
	*
	* Given a numerical temperature $temp in Celsius, coded to tenth of
	* degree, store in $temp_c, convert to Fahrenheit and store in
	* $temp_f.
	*
	* @param string   Temperature to convert, coded to tenth of
	* 		     degree, like 1015
	* @param   integer   Temperature measured in degrees Celsius
	* @param   integer   Temperature measured in degrees Fahrenheit
	* @access  private
	*/
	function store_temp($temp, &$temp_c, &$temp_f) {
		/*
		* Note: $temp is converted to negative if $temp > 100.0 (See
		* Federal Meteorological Handbook for groups T, 1, 2 and 4).
		* For example, a temperature of 2.6?C and dew point of -1.5?C
		* would be reported in the body of the report as "03/M01" and the
		* TsnT'T'T'snT'dT'dT'd group as "T00261015").
		*/

		if ($temp[0] == 1) {
			$temp[0] = '-';
		}
		$temp_c = number_format($temp,1);
		/* The temperature in Fahrenheit. */
		$temp_f = number_format($temp * (9/5) + 32, 1);
	}


	/**
	* Helper-function used to store speeds.
	*
	* $value is converted and stored based on $windunit.
	*
	* @param  float   The value one seeks to convert.
	* @param  string  The unit of $value.
	* @param  float &$knots   After $value has been converted into knots,
	*			     it will be stored in this variable.
	* @param  float &$meterspersec   After $value has been converted into
	*				    meters per second, it will be stored
	*				    in this variable.
	* @param  float &$milesperhour   After $value has been converted into
	*				    miles per hour, it will be stored
	*				    in this variable.
	* @access  private
	*/
	function store_speed($value, $windunit, &$knots, &$meterspersec, &$milesperhour) {
		if ($value == 0) {
			$knots = 0;
			$meterspersec = 0;
			$milesperhour = 0;
			return;
		}

		if ($windunit == 'KT') {
			/* The windspeed measured in knots: */
			$knots        = number_format($value);
			/* The windspeed measured in meters per second, rounded to one
			decimal place  */
			$meterspersec = number_format($value * 0.5144, 1);
			/* The windspeed measured in miles per hour, rounded to one
			decimal place */
			$milesperhour = number_format($value * 1.1508, 1);
		}
		elseif ($windunit == 'MPS') {
			/* The windspeed measured in meters per second */
			$meterspersec = number_format($value);
			/* The windspeed measured in knots, rounded to one decimal
			place */
			$knots        = number_format($value / 0.5144, 1);
			/* The windspeed measured in miles per hour, rounded to one
			decimal place */
			$milesperhour = number_format($value / 0.5144 * 1.1508, 1);
		}
		elseif ($windunit == 'KMH') {
			/* The windspeed measured in kilometers per hour */
			$meterspersec = number_format($value * 1000 / 3600, 1);
			$knots        = number_format($value * 1000 / 3600 / 0.5144, 1);
			/* The windspeed measured in miles per hour, rounded to one
			decimal place */
			$milesperhour = number_format($knots * 1.1508, 1);
		}
	}


	/**
	* Decodes a raw METAR.
	*
	* This function loops over the various parts of the raw METAR, and
	* stores the different bits in $decoded_metar. It uses get_metar() to
	* retrieve the METAR, so it is not necessary to connect to the database
	* before you call this function.
	*
	* @return  array   The decoded METAR.
	* @see     $decoded_metar
	* @access  public
	*/
	function decode_metar($metar='') {
		/* initialization */
		$temp_visibility_miles = '';

		$decoded_metar = array();

		$decoded_metar['remarks'] = '';

		$decoded_metar['metar'] = $metar;
		$decoded_metar['location'] = $this->get_location();

		$parts = explode(' ', $metar);
		$num_parts = count($parts);
		$pastrem = 0;
		for ($i = 0; $i < $num_parts; $i++) {
			$part = $parts[$i];
			//                        echo $part . "<br />";

			if (ereg('RMK|TEMPO|BECMG|INTER', $part)) {
				/* The rest of the METAR is either a remark or temporary
				* information. We skip the rest of the METAR.
				*/
				$decoded_metar['remarks'] .= ' ' . $part;
				$pastrem = 1;
				//				break;
			}

			if (! $pastrem) {
				if ($part == 'METAR') {
					/*
					* Type of Report: METAR
					*/
					$decoded_metar['type'] = 'METAR';
				}
				elseif ($part == 'SPECI') {
					/*
					* Type of Report: SPECI
					*/
					$decoded_metar['type'] = 'SPECI';
				}
				elseif (ereg('^[A-Z]{4}$', $part) &&  empty($decoded_metar['icao']))  {
					/*
					* Station Identifier
					*/
					$decoded_metar['icao']  = $part;
				}
				elseif (ereg('([0-9]{2})([0-9]{2})([0-9]{2})Z', $part, $regs)) {
					/*
					* Date and Time of Report.
					*
					* We return a standard Unix UTC/GMT timestamp suitable for
					* gmdate().
					* Due to a bug in PHP, on some systems the time reported may
					* be incorrect. If you experience this, you can set
					* $this->properties['offset'] to be the offset to add. For
					* example, if your times generated are 1 hour too early (so
					* metars appear an hour older than they are), set
					* $this->properties['offset'] to be +1 in your defaults.php
					* file.
					*/
					if ($regs[1] > gmdate('j')) {
						/* The day is greather that the current day of month => the
						* report is from last month.
						*/
						$month = gmdate('n') - 1;
					} else {
						$month = gmdate('n');
					}
					$decoded_metar['time'] =
					        gmmktime($regs[2] + $this->properties['offset'],
					                 $regs[3], 0, $month, $regs[1], gmdate('Y'));
				}
				elseif (ereg('(AUTO|COR|RTD|CC[A-Z]|RR[A-Z])', $part, $regs)) {

					/*
					* Report Modifier: AUTO, COR, CCx or RRx
					*/
					$decoded_metar['report_mod'] = $regs[1];
				}
				elseif (ereg('([0-9]{3}|VRB)([0-9]{2,3})G?([0-9]{2,3})?(KT|MPS|KMH)', $part, $regs)) {

					/* Wind Group */

					$decoded_metar['wind']['deg'] = $regs[1];

					$this->store_speed($regs[2],
					                   $regs[4],
					                   $decoded_metar['wind']['knots'],
					                   $decoded_metar['wind']['meters_per_second'],
					                   $decoded_metar['wind']['miles_per_hour']);

					if (!empty($regs[3])) {

						/* We have a report with information about the gust.
						* First we have the gust measured in knots.
						*/
						$this->store_speed($regs[3],
						                   $regs[4],
						                   $decoded_metar['wind']['gust_knots'],
						                   $decoded_metar['wind']['gust_meters_per_second'],
						                   $decoded_metar['wind']['gust_miles_per_hour']);
					}
				}
				elseif (ereg('^([0-9]{3})V([0-9]{3})$', $part, $regs) && !empty($decoded_metar['wind'])) {

					/*
					* Variable wind-direction
					*/
					$decoded_metar['wind']['var_beg'] = $regs[1];
					$decoded_metar['wind']['var_end'] = $regs[2];
				}
				elseif (ereg('^([0-9]{4})([NS]?[EW]?)$', $part, $regs)) {
					/*
					* Visibility in meters (4 digits only)
					*/
					unset($group);

					if ($regs[1] == '0000') {
						/* Special low value */

						$group['prefix'] = -1; /* Less than */
						$group['meter']  = 50;
						$group['km']     = 0.05;
						$group['ft']     = 164;
						$group['miles']  = 0.031;
					}
					elseif ($regs[1] == '9999') {
						/* Special high value */
						$group['prefix'] = 1;
						$group['meter']  = 10000;
						$group['km']     = 10;
						$group['ft']     = 32800;
						$group['miles']  = 6.2;
					}
					else {
						/* Normal visibility, returned in both small and large units. */
						$group['prefix'] = 0;
						$group['km']     = number_format($regs[1]/1000, 1);
						$group['miles']  = number_format($regs[1]/1609.344, 1);
						$group['meter']  = $regs[1] * 1;
						$group['ft']     = round($regs[1] * 3.28084);
					}
					if (!empty($regs[2])) {
						$group['dir'] = $regs[2];
					}
					$decoded_metar['visibility'][] = $group;

				}
				elseif (ereg('^[0-9]$', $part)) {
					/*
					* Temp Visibility Group, single digit followed by space.
					*/
					$temp_visibility_miles = $part;
				}
				elseif (ereg('^M?(([0-9]?)[ ]?([0-9])(/?)([0-9]*))SM$', $temp_visibility_miles . ' ' . $part, $regs)) {
					/*
					* Visibility Group
					*/
					unset($group);

					if ($regs[4] == '/') {
						$vis_miles = $regs[2] + $regs[3]/$regs[5];
					} else {
						$vis_miles = $regs[1];
					}
					if ($regs[0][0] == 'M') {
						/* Prefix - less than */
						$group['prefix'] = -1;
					} else {
						$group['prefix'] = 0;
					}

					/* The visibility measured in miles */
					$group['miles']  = number_format($vis_miles, 1);

					/* The visibility measured in feet */
					$group['ft']     = round($vis_miles * 5280, 1);

					/* The visibility measured in kilometers */
					$group['km']     = number_format($vis_miles * 1.6093, 1);

					/* The visibility measured in meters */
					$group['meter']  = round($vis_miles * 1609.3);

					$decoded_metar['visibility'][] = $group;
				}
				elseif ($part == 'CAVOK') {
					/* CAVOK is used when the visibility is greater than 10
					* kilometers, the lowest cloud-base is at 5000 feet or more
					* and there is no significant weather.
					*/
					unset($group);
					$group['prefix'] = 1;
					$group['km']     = 10;
					$group['meter']  = 10000;
					$group['miles']  = 6.2;
					$group['ft']     = 32800;
					$decoded_metar['visibility'][] = $group;
					$decoded_metar['clouds'][]['condition'] = 'CAVOK';

				}
				elseif (ereg('^R([0-9]{2})([RLC]?)/([MP]?)([0-9]{4})' . '([DNU]?)V?(P?)([0-9]{4})?([DNU]?)$', $part, $regs)) {
					/* Runway-group */
					unset($group);
					$group['nr'] = $regs[1];
					if (!empty($regs[2])) {
						$group['approach'] = $regs[2];
					}

					if (!empty($regs[7])) {
						/* We have both min and max visibility since $regs[7] holds
						* the max visibility.
						*/
						if (!empty($regs[5])) {
							/* $regs[5] is tendency for min visibility. */
							$group['min_tendency'] = $regs[5];
						}

						if (!empty($regs[8])) {
							/* $regs[8] is tendency for max visibility. */
							$group['max_tendency'] = $regs[8];
						}

						if ($regs[3] == 'M') {
							/* Less than. */
							$group['min_prefix'] = -1;
						}
						$group['min_meter'] = $regs[4] * 1;
						$group['min_ft']    = round($regs[4] * 3.2808);

						if ($regs[6] == 'P') {
							/* Greater than. */
							$group['max_prefix'] = 1;
						}
						$group['max_meter'] = $regs[7] * 1;
						$group['max_ft']    = round($regs[7] * 3.2808);

					} else {
						/* We only have a single visibility. */

						if (!empty($regs[5])) {
							/* $regs[5] holds the tendency for visibility. */
							$group['tendency'] = $regs[5];
						}

						if ($regs[3] == 'M') {
							/* Less than. */
							$group['prefix'] = -1;
						}
						elseif ($regs[3] == 'P') {
							/* Greater than. */
							$group['prefix'] = 1;
						}
						$group['meter'] = $regs[4] * 1;
						$group['ft']    = round($regs[4] * 3.2808);
					}
					$decoded_metar['runway'][] = $group;

				}
				elseif (ereg('^(VC)?' .                           /* Proximity */
				             '(-|\+)?' .                          /* Intensity */
				             '(MI|PR|BC|DR|BL|SH|TS|FZ)?' .       /* Descriptor */
				             '((DZ|RA|SN|SG|IC|PL|GR|GS|UP)+)?' . /* Precipitation */
				             '(BR|FG|FU|VA|DU|SA|HZ|PY)?' .       /* Obscuration */
				             '(PO|SQ|FC|SS)?$',                   /* Other */
				             $part, $regs)) {
					/*
					* Current weather-group.
					*/
					$decoded_metar['weathergroup'][] =
					        array('proximity'     => $regs[1],
					              'intensity'     => $regs[2],
					              'descriptor'    => $regs[3],
					              'precipitation' => $regs[4],
					              'obscuration'   => $regs[6],
					              'other'         => $regs[7]);
				}
				elseif (($part == 'SKC') || ($part == 'CLR')) {
					/* Cloud-group */
					$decoded_metar['clouds'][]['condition'] = $part;

				}
				elseif (ereg('^(VV|FEW|SCT|BKN|OVC)([0-9]{3}|///)' . '(CB|TCU)?$', $part, $regs)) {
					/* We have found (another) a cloud-layer-group. */
					unset($group);

					$group['condition'] = $regs[1];
					if (!empty($regs[3])) {
						$group['cumulus'] = $regs[3];
					}
					if ($regs[2] == '000') {
						/* '000' is a special height. */
						$group['ft']     = 100;
						$group['meter']  = 30;
						$group['prefix'] = -1; /* Less than */
					}
					elseif ($regs[2] == '///') {
						/* '///' means height nil */
						$group['ft']     = 'nil';
						$group['meter']  = 'nil';
					}
					else {
						$group['ft']     = $regs[2] *100;
						$group['meter']  = round($regs[2] * 30.48);
					}
					$decoded_metar['clouds'][] = $group;

				}
				elseif (ereg('^(M?[0-9]{2})/(M?[0-9]{2})?$', $part, $regs)) {
					/*
					* Temperature/Dew Point Group.
					*/
					$decoded_metar['temperature']['temp_c'] =
					        round(strtr($regs[1], 'M', '-'));
					$decoded_metar['temperature']['temp_f'] =
					        round(strtr($regs[1], 'M', '-') * (9/5) + 32);
					if (!empty($regs[2])) {
						$decoded_metar['temperature']['dew_c'] =
						        round(strtr($regs[2], 'M', '-'));
						$decoded_metar['temperature']['dew_f'] =
						        round(strtr($regs[2], 'M', '-') * (9/5) + 32);
					}
				}
				elseif (ereg('A([0-9]{4})', $part, $regs)) {
					/*
					* Altimeter.
					* The pressure measured in inHg.
					*/
					$decoded_metar['altimeter']['inhg'] =
					        number_format($regs[1]/100, 2);

					/* The pressure measured in mmHg, hPa and atm */
					$decoded_metar['altimeter']['mmhg'] =
					        number_format($regs[1] * 0.254, 1, '.', '');
					$decoded_metar['altimeter']['hpa']  =
					        round($regs[1] * 0.33864);
					$decoded_metar['altimeter']['atm']  =
					        number_format($regs[1] * 3.3421e-4, 3, '.', '');
				}
				elseif (ereg('Q([0-9]{4})', $part, $regs)) {
					/*
					* Altimeter.
					* The specification doesn't say anything about
					* the Qxxxx-form, but it's in the METARs.
					*/

					/* The pressure measured in hPa */
					$decoded_metar['altimeter']['hpa']  = round($regs[1]);

					/* The pressure measured in mmHg, inHg and atm */
					$decoded_metar['altimeter']['mmhg'] =
					        number_format($regs[1] * 0.75006, 1, '.', '');
					$decoded_metar['altimeter']['inhg'] =
					        number_format($regs[1] * 0.02953, 2);
					$decoded_metar['altimeter']['atm']  =
					        number_format($regs[1] * 9.8692e-4, 3, '.', '');
				}
				elseif (ereg('^T([0-9]{4})([0-9]{4})', $part, $regs)) {

					/*
					* Temperature/Dew Point Group, coded to tenth of degree Celsius.
					*/
					$this->store_temp($regs[1] / 10,
					                  $decoded_metar['temperature']['temp_c'],
					                  $decoded_metar['temperature']['temp_f']);
					$this->store_temp($regs[2] / 10,
					                  $decoded_metar['temperature']['dew_c'],
					                  $decoded_metar['temperature']['dew_f']);
				}
				elseif (ereg('^T([0-9]{4}$)', $part, $regs)) {
					$this->store_temp($regs[1],
					                  $decoded_metar['temperature']['temp_c'],
					                  $decoded_metar['temperature']['temp_f']);
				} else {
				}
			} else {
				if (ereg('^(PRESFR|PRESRR)', $part, $regs)) {
					$decoded_metar['altimeter']['direction'] = $regs[1];
				}
				elseif (ereg('^(SNINCR)', $part, $regs)) {
					$decoded_metar['precipitation']['direction'] = $regs[1];
				}
				elseif (ereg('^1([0-9]{4}$)', $part, $regs)) {

					/*
					* 6 hour maximum temperature Celsius, coded to tenth of degree
					*/
					$this->store_temp($regs[1] / 10,
					                  $decoded_metar['temp_min_max']['max6h_c'],
					                  $decoded_metar['temp_min_max']['max6h_f']);
				}
				elseif (ereg('^2([0-9]{4}$)', $part, $regs)) {

					/*
					* 6 hour minimum temperature Celsius, coded to tenth of degree
					*/
					$this->store_temp($regs[1] / 10,
					                  $decoded_metar['temp_min_max']['min6h_c'],
					                  $decoded_metar['temp_min_max']['min6h_f']);
				}
				elseif (ereg('^4([0-9]{4})([0-9]{4})$', $part, $regs)) {

					/*
					* 24 hour maximum and minimum temperature Celsius, coded to
					* tenth of degree
					*/
					$this->store_temp($regs[1] / 10,
					                  $decoded_metar['temp_min_max']['max24h_c'],
					                  $decoded_metar['temp_min_max']['max24h_f']);
					$this->store_temp($regs[2] / 10,
					                  $decoded_metar['temp_min_max']['min24h_c'],
					                  $decoded_metar['temp_min_max']['min24h_f']);
				}
				elseif (ereg('^P([0-9]{4})', $part, $regs)) {

					/*
					* Precipitation during last hour in hundredths of an inch
					*/
					if ($regs[1] == '0000') {
						$decoded_metar['precipitation']['in'] = -1;
						$decoded_metar['precipitation']['mm'] = -1;
					} else {
						$decoded_metar['precipitation']['in'] =
						        number_format($regs[1]/100, 2);
						$decoded_metar['precipitation']['mm'] =
						        number_format($regs[1]*0.254, 2);
					}
				}
				elseif (ereg('^6([0-9]{4})', $part, $regs)) {

					/*
					* Precipitation during last 3 or 6 hours in hundredths of an
					* inch.
					*/
					if ($regs[1] == '0000') {
						$decoded_metar['precipitation']['in_6h'] = -1;
						$decoded_metar['precipitation']['mm_6h'] = -1;
					} else {
						$decoded_metar['precipitation']['in_6h'] =
						        number_format(intval($regs[1])/100, 2);
						$decoded_metar['precipitation']['mm_6h'] =
						        number_format(intval($regs[1])*0.254, 2);
					}
				}
				elseif (ereg('^7([0-9]{4})', $part, $regs)) {

					/*
					* Precipitation during last 24 hours in hundredths of an inch.
					*/
					if ($regs[1] == '0000') {
						$decoded_metar['precipitation']['in_24h'] = -1;
						$decoded_metar['precipitation']['mm_24h'] = -1;
					} else {
						$decoded_metar['precipitation']['in_24h'] =
						        number_format(intval($regs[1])/100, 2, '.', '');
						$decoded_metar['precipitation']['mm_24h'] =
						        number_format(intval($regs[1])*0.254, 2, '.', '');
					}
				}
				elseif (ereg('^4/([0-9]{3})', $part, $regs)) {

					/*
					* Snow depth in inches
					*/
					if ($regs[1] == '0000') {
						$decoded_metar['precipitation']['snow_in'] = -1;
						$decoded_metar['precipitation']['snow_mm'] = -1;
					} else {
						$decoded_metar['precipitation']['snow_in'] = intval($regs[1]) * 1;
						$decoded_metar['precipitation']['snow_mm'] = round(intval($regs[1]) * 25.4);
					}
				}
				else {

					/*
					* If we couldn't match the group, we assume that it was a
					* remark.
					*/
					$decoded_metar['remarks'] .= ' ' . $part;
				}
			}
		}

		/*
		* Relative humidity
		*/
		if (!empty($decoded_metar['temperature']['temp_c']) && 	!empty($decoded_metar['temperature']['dew_c'])) {

			$decoded_metar['rel_humidity'] =
			        number_format(pow(10, (1779.75 * ($decoded_metar['temperature']['dew_c'] -
			                                          $decoded_metar['temperature']['temp_c'])
			                               / ((237.3 + $decoded_metar['temperature']['dew_c']) *
			                                  (237.3 + $decoded_metar['temperature']['temp_c']))
			                               + 2)));
		}


		/*
		*  Compute windchill if temp < 40f and windspeed > 3 mph
		*/
		if (!empty($decoded_metar['temperature']['temp_f']) && 	$decoded_metar['temperature']['temp_f'] <= 40 && !empty($decoded_metar['wind']['miles_per_hour']) && $decoded_metar['wind']['miles_per_hour'] > 3) {
			$decoded_metar['windchill']['windchill_f'] =
			        number_format(35.74 + 0.6215*$decoded_metar['temperature']['temp_f']
			                      - 35.75*pow((float)$decoded_metar['wind']['miles_per_hour'], 0.16)
			                      + 0.4275*$decoded_metar['temperature']['temp_f'] *
			                      pow((float)$decoded_metar['wind']['miles_per_hour'], 0.16));
			$decoded_metar['windchill']['windchill_c'] =
			        number_format(13.112 + 0.6215*$decoded_metar['temperature']['temp_c']
			                      - 13.37*pow(($decoded_metar['wind']['miles_per_hour']/1.609), 0.16)
			                      + 0.3965*$decoded_metar['temperature']['temp_c'] *
			                      pow(($decoded_metar['wind']['miles_per_hour']/1.609), 0.16));
		}

		/*
		* Compute heat index if temp > 70F
		*/
		if (!empty($decoded_metar['temperature']['temp_f']) && 	$decoded_metar['temperature']['temp_f'] > 70 && !empty($decoded_metar['rel_humidity'])) {
			$decoded_metar['heatindex']['heatindex_f'] =
			        number_format(-42.379
			                      + 2.04901523 * $decoded_metar['temperature']['temp_f']
			                      + 10.1433312 * $decoded_metar['rel_humidity']
			                      - 0.22475541 * $decoded_metar['temperature']['temp_f']
			                      * $decoded_metar['rel_humidity']
			                      - 0.00683783 * $decoded_metar['temperature']['temp_f']
			                      * $decoded_metar['temperature']['temp_f']
			                      - 0.05481717 * $decoded_metar['rel_humidity']
			                      * $decoded_metar['rel_humidity']
			                      + 0.00122874 * $decoded_metar['temperature']['temp_f']
			                      * $decoded_metar['temperature']['temp_f']
			                      * $decoded_metar['rel_humidity']
			                      + 0.00085282 * $decoded_metar['temperature']['temp_f']
			                      * $decoded_metar['rel_humidity']
			                      * $decoded_metar['rel_humidity']
			                      - 0.00000199 * $decoded_metar['temperature']['temp_f']
			                      * $decoded_metar['temperature']['temp_f']
			                      * $decoded_metar['rel_humidity']
			                      * $decoded_metar['rel_humidity']);
			$decoded_metar['heatindex']['heatindex_c'] =
			        number_format(($decoded_metar['heatindex']['heatindex_f'] - 32) / 1.8);
		}

		/*
		* Compute the humidity index
		*/
		if (!empty($decoded_metar['rel_humidity'])) {
			$e = (6.112 * pow(10, 7.5 * $decoded_metar['temperature']['temp_c']
			                  / (237.7 + $decoded_metar['temperature']['temp_c']))
			      * $decoded_metar['rel_humidity'] / 100) - 10;
			$decoded_metar['humidex']['humidex_c'] =
			        number_format($decoded_metar['temperature']['temp_c'] + 5/9 * $e, 1);
			$decoded_metar['humidex']['humidex_f'] =
			        number_format($decoded_metar['humidex']['humidex_c'] * 9/5 + 32, 1);
		}


		/* Finally we store our decoded METAR in $this->decoded_metar so
		* that other methods can use it.
		*/
		//		$this->decoded_metar = $decoded_metar;
		return $decoded_metar;
	}


	function interpret_metar() {
		$this->metar = $this->get_metar();
		$this->pmetar = $this->get_pmetar();
		if (!empty($this->pmetar)) {
			$this->decoded_pmetar = $this->decode_metar($this->pmetar);
		}
		$this->decoded_metar = $this->decode_metar($this->metar);
		/*
				echo $this->metar . "<BR / >";
				echo $this->pmetar . "<BR / >";
				echo date("m/d/y g:i a", $this->decoded_metar['time']) . "<br / >";
				echo date("m/d/y g:i a", $this->decoded_pmetar['time']) . "<br / >";
				echo $this->decoded_metar['time'] . "<br />";
				echo $this->decoded_pmetar['time'] . "<br />";
				$difftime = $this->decoded_metar['time'] - $this->decoded_pmetar['time'];
				echo $difftime . "<br />";
		*/
		$prefunits = $this->properties['pref_units'];
		/* initialization */
		$temp_visibility_miles = '';

		//		$decoded_metar['remarks'] = '';

		//		$decoded_metar['metar'] = $this->get_metar();

		$imblock['location'] = $this->get_first_location();
		$imblock['forecastlink'] = $this->get_forecast_link();
		$imblock['remarks'] = $this->decoded_metar['remarks'];
		$imblock['icao'] = $this->decoded_metar['icao'];
		$imblock['time'] = $this->decoded_metar['time'];

		if (isset($this->decoded_metar['report_mod'])) {
			$imblock['modifier'] = $this->decoded_metar['report_mod'];
		}

		$imblock['windspeed'] = '';
		if (isset($this->decoded_metar['wind']['meters_per_second']) && !empty($this->decoded_metar['wind']['meters_per_second'])) {
			switch ($prefunits) {
			case 'both_metric':
				$imblock['windspeed'] = $this->decoded_metar['wind']['meters_per_second'] . "&nbsp;mps (" . $this->decoded_metar['wind']['miles_per_hour'] . "&nbsp;mph)";
				break;
			case 'only_imperial':
				$imblock['windspeed'] = $this->decoded_metar['wind']['miles_per_hour'] . "&nbsp;mph";
				break;
			case 'only_metric':
				$imblock['windspeed'] = $this->decoded_metar['wind']['meters_per_second'] . "&nbsp;mps";
				break;
			default:
			case 'both_imperial':
				$imblock['windspeed'] = $this->decoded_metar['wind']['miles_per_hour'] . "&nbsp;mph (" . $this->decoded_metar['wind']['meters_per_second'] . "&nbsp;mps)";
				break;
			}
		}

		/*
		* If wind speed is rising or falling,
		* show that with + or -
		* let calling function interpret that into text
		*/
		$imblock['windtrend'] = '';
		if (isset($this->decoded_pmetar['wind']['meters_per_second'])) {
			if ($this->decoded_pmetar['wind']['meters_per_second'] != $this->decoded_metar['wind']['meters_per_second']) {
				if ($this->decoded_pmetar['wind']['meters_per_second'] > $this->decoded_metar['wind']['meters_per_second']) {
					$imblock['windtrend'] = '-';
				} else {
					$imblock['windtrend'] = '+';
				}
			}
		}

		$imblock['gusts'] = '';
		if (isset($this->decoded_metar['wind']['gust_meters_per_second']) && !empty($this->decoded_metar['wind']['gust_meters_per_second'])) {
			switch ($prefunits) {
			case 'both_metric':
				$imblock['gusts'] = $this->decoded_metar['wind']['gust_meters_per_second'] . "&nbsp;mps (" . $this->decoded_metar['wind']['gust_miles_per_hour'] . "&nbsp;mph)";
				break;
			case 'only_imperial':
				$imblock['gusts'] = $this->decoded_metar['wind']['gust_miles_per_hour'] . "&nbsp;mph";
				break;
			case 'only_metric':
				$imblock['gusts'] = $this->decoded_metar['wind']['gust_meters_per_second'] . "&nbsp;mps";
				break;
			default:
			case 'both_imperial':
				$imblock['gusts'] = $this->decoded_metar['wind']['gust_miles_per_hour'] . "&nbsp;mph (" . $this->decoded_metar['wind']['gust_meters_per_second'] . "&nbsp;mps)";
				break;
			}
		}
		if (isset($this->decoded_metar['wind']['deg'])) {
			$wdeg = $this->decoded_metar['wind']['deg'];
			$imblock['wdirlong'] = '';
			$imblock['wdirshort'] = '';
			if ($wdeg == "VRB") {
				$imblock['wdirlong'] = _VL_BL_VARLONG;
				$imblock['wdirshort'] = _VL_BL_VARSHORT;
			} else {
				if ($wdeg < 15) {
					$imblock['wdirlong'] = _VL_BL_NLONG;
					$imblock['wdirshort'] = _VL_BL_NSHORT;
				}
				elseif ($wdeg < 30) {
					$imblock['wdirlong'] = _VL_BL_NNELONG;
					$imblock['wdirshort'] = _VL_BL_NNESHORT;
				}
				elseif ($wdeg < 60) {
					$imblock['wdirlong'] = _VL_BL_NELONG;
					$imblock['wdirshort'] = _VL_BL_NESHORT;
				}
				elseif ($wdeg < 75) {
					$imblock['wdirlong'] = _VL_BL_ENELONG;
					$imblock['wdirshort'] = _VL_BL_ENESHORT;
				}
				elseif ($wdeg < 105) {
					$imblock['wdirlong'] = _VL_BL_ELONG;
					$imblock['wdirshort'] = _VL_BL_ESHORT;
				}
				elseif ($wdeg < 120) {
					$imblock['wdirlong'] = _VL_BL_ESELONG;
					$imblock['wdirshort'] = _VL_BL_ESESHORT;
				}
				elseif ($wdeg < 150) {
					$imblock['wdirlong'] = _VL_BL_SELONG;
					$imblock['wdirshort'] = _VL_BL_SESHORT;
				}
				elseif ($wdeg < 165) {
					$imblock['wdirlong'] = _VL_BL_SSELONG;
					$imblock['wdirshort'] = _VL_BL_SSESHORT;
				}
				elseif ($wdeg < 195) {
					$imblock['wdirlong'] = _VL_BL_SLONG;
					$imblock['wdirshort'] = _VL_BL_SSHORT;
				}
				elseif ($wdeg < 210) {
					$imblock['wdirlong'] = _VL_BL_SSWLONG;
					$imblock['wdirshort'] = _VL_BL_SSWSHORT;
				}
				elseif ($wdeg < 240) {
					$imblock['wdirlong'] = _VL_BL_SWLONG;
					$imblock['wdirshort'] = _VL_BL_SWSHORT;
				}
				elseif ($wdeg < 265) {
					$imblock['wdirlong'] = _VL_BL_WSWLONG;
					$imblock['wdirshort'] = _VL_BL_WSWSHORT;
				}
				elseif ($wdeg < 285) {
					$imblock['wdirlong'] = _VL_BL_WLONG;
					$imblock['wdirshort'] = _VL_BL_WSHORT;
				}
				elseif ($wdeg < 300) {
					$imblock['wdirlong'] = _VL_BL_WNWLONG;
					$imblock['wdirshort'] = _VL_BL_WNWSHORT;
				}
				elseif ($wdeg < 330) {
					$imblock['wdirlong'] = _VL_BL_NWLONG;
					$imblock['wdirshort'] = _VL_BL_NWSHORT;
				}
				elseif ($wdeg < 345) {
					$imblock['wdirlong'] = _VL_BL_NNWLONG;
					$imblock['wdirshort'] = _VL_BL_NNWSHORT;
				}
				else {
					$imblock['wdirlong'] = _VL_BL_NLONG;
					$imblock['wdirshort'] = _VL_BL_NSHORT;
				}
			}
		}

		if (isset($this->decoded_metar['wind']['var_beg'])) {
			$wdir = $this->decoded_metar['wind']['var_beg'] . $this->decoded_metar['wind']['var_end'];
		}

      /* Start with extreme conditions */

		$imblock['conditions'] = '';

      /* Extreme heat */
      if ($this->decoded_metar['temperature']['temp_f'] >= 100) {
         $imblock['extreme'] = 'hot';
      }
	   if (isset($this->decoded_metar['heatindex']['heatindex_f']) && 
 			($this->decoded_metar['heatindex']['heatindex_f'] >= 100)) {
         $imblock['extreme'] = 'hot';
    	}

      /* Extreme cold */
      if ($this->decoded_metar['temperature']['temp_f'] < 0) {
         $imblock['extreme'] = 'cold';
    	}
  	   if (isset($this->$decoded_metar['windchill']['windchill_f']) && 
        ($this->$decoded_metar['windchill']['windchill_f'] < 0)) {
        $imblock['extreme'] = 'cold';
 		}
		
    	if (isset($imblock['extreme']) && ! empty($imblock['extreme'])) {
    	   $imblock['conditions'] .= $imblock['extreme'];
    	}
    	
		for ($i=0;$i<5;$i++) {
			$conditions = '';
			$imblock['intensity'] = '';
			$imblock['proximity'] = '';
			$imblock['descriptor'] = '';
			$imblock['precipitation'] = '';
			$imblock['obscuration'] = '';
			$imblock['other'] = '';

			if (isset($this->decoded_metar['weathergroup'][$i])) {
				$intensity = $this->decoded_metar['weathergroup'][$i]['intensity'];
				if (!empty($intensity)) {
				switch ($intensity) {
				case '-':
					$imblock['intensity'] = _VL_BL_LIGHT;
					break;
				case '+':
					$imblock['intensity'] = _VL_BL_HEAVY;
					break;
				}
			}
			$proximity = $this->decoded_metar['weathergroup'][$i]['proximity'];
			if (!empty($proximity)) {
				switch ($proximity) {
				case 'VC':
					$imblock['proximity'] = _VL_BL_VICIN;
					break;
				default:
					$imblock['proximity'] = '';
					break;
				}
			}
			$descr = $this->decoded_metar['weathergroup'][$i]['descriptor'];
			if (!empty($descr)) {
				switch ($descr) {
				case 'MI':
					$imblock['descriptor'] = _VL_BL_SHALLOW;
					break;
				case 'PR':
					$imblock['descriptor'] = _VL_BL_PARTIAL;
					break;
				case 'BC':
					$imblock['descriptor'] = _VL_BL_PATCH;
					break;
				case 'DR':
					$imblock['descriptor'] = _VL_BL_DRIFT;
					break;
				case 'BL':
					$imblock['descriptor'] = _VL_BL_BLOW;
					break;
				case 'SH':
					$imblock['descriptor'] = _VL_BL_SHOW;
					break;
				case 'TS':
					$imblock['descriptor'] = _VL_BL_THUN;
					break;
				case 'FZ':
					$imblock['descriptor'] = _VL_BL_FRZ;
					break;
				default:
					break;
				}
			}
			$precip = $this->decoded_metar['weathergroup'][$i]['precipitation'];
			if (!empty($precip)) {
				switch ($precip) {
				case 'DZ':
					$imblock['precipitation'] = _VL_BL_DZ;
					break;
				case 'RA':
					$imblock['precipitation'] = _VL_BL_RA;
					break;
				case 'SN':
					$imblock['precipitation'] = _VL_BL_SN;
					break;
				case 'SG':
					$imblock['precipitation'] = _VL_BL_SG;
					break;
				case 'IC':
					$imblock['precipitation'] = _VL_BL_IC;
					break;
				case 'PL':
					$imblock['precipitation'] = _VL_BL_PL;
					break;
				case 'GR':
					$imblock['precipitation'] = _VL_BL_GR;
					break;
				case 'GS':
					$imblock['precipitation'] = _VL_BL_GS;
					break;
				case 'UP':
					$imblock['precipitation'] = _VL_BL_UP;
					break;
				default:
					break;
				}
			}

			$obscure = $this->decoded_metar['weathergroup'][$i]['obscuration'];
			if (!empty($obscure)) {
				switch ($obscure) {
				case 'BR':
					$imblock['obscuration'] = _VL_BL_BR;
					break;
				case 'FG':
					$imblock['obscuration'] = _VL_BL_FG;
					break;
				case 'FU':
					$imblock['obscuration'] = _VL_BL_FU;
					break;
				case 'VA':
					$imblock['obscuration'] = _VL_BL_VA;
					break;
				case 'DU':
					$imblock['obscuration'] = _VL_BL_DU;
					break;
				case 'SA':
					$imblock['obscuration'] = _VL_BL_SA;
					break;
				case 'HZ':
					$imblock['obscuration'] = _VL_BL_HZ;
					break;
				case 'PY':
					$imblock['obscuration'] = _VL_BL_PY;
					break;
				default:
					$imblock['obscuration'] = '';
					break;
				}
			}
			$other = $this->decoded_metar['weathergroup'][$i]['other'];
			switch($other) {
			case 'PO':
				$imblock['other'] = _VL_BL_PO;
				break;
			case 'SQ':
				$imblock['other'] = _VL_BL_SQL;
				break;
			case 'FC':
				if ($intensity == "+") {
					$imblock['other'] = _VL_BL_FC1;
				} else {
					$imblock['other'] = _VL_BL_FC2;
				}
				break;
			case 'SS':
				$imblock['other'] = _VL_BL_SS;
				break;
			case 'DS':
				$imblock['other'] = _VL_BL_DS;
				break;
			}
		}

			$conditions = $imblock['intensity'] . " " . $imblock['descriptor'] . " " . $imblock['precipitation'] . " " . $imblock['obscuration'] . " " . $imblock['other'] . " " . $imblock['proximity'];
			$conditions = trim($conditions);
			if (($conditions != '') && ($i > 0)) {
				$imblock['conditions'] .= ', ';
			}
			$imblock['conditions'] .= $conditions;

		}

		$imblock['sky'] = '';
		if (isset($this->decoded_metar['clouds'])) {
			$sky1 = '';
			$sky2 = '';
			$sky3 = '';
			if (isset($this->decoded_metar['clouds'][0])) {
				$sky1 = $this->decoded_metar['clouds'][0]['condition'];
			}
			if (isset($this->decoded_metar['clouds'][1])) {
				$sky2 = $this->decoded_metar['clouds'][1]['condition'];
			}
			if (isset($this->decoded_metar['clouds'][2])) {
				$sky3 = $this->decoded_metar['clouds'][2]['condition'];
			}
			if ($sky1 == 'VV') {
			  $sky1 = 'OVC';
			}
			$weight = $this->weight_sky($sky1, $sky2, $sky3);
			if (empty($sky1) && empty($sky2) && empty($sky3)) {
				$sky = '';
			} else {
				$sky = $this->get_sky($weight,'sky',0);
				if (!empty($sky)) {
					switch ($sky) {
					case 'SKC':
						$imblock['sky'] = _VL_BL_SKC;
						break;
					case 'CLR':
						$imblock['sky'] = _VL_BL_CLR;
						break;
					case 'FEW':
						$imblock['sky'] = _VL_BL_FEW;
						break;
					case 'SCT':
						$imblock['sky'] = _VL_BL_SCT;
						break;
					case 'BKN':
						$imblock['sky'] = _VL_BL_BKN;
						break;
					case 'OVC':
						$imblock['sky'] = _VL_BL_OVC;
						break;
					default:
						$imblock['sky'] = '';
						break;
					}
				}
			}
		}

		$imblock['temp'] = '';
		if (isset($this->decoded_metar['temperature'])) {
			if (isset($this->decoded_metar['temperature']['temp_f'])) {
				$tempf = $this->decoded_metar['temperature']['temp_f'] . "&nbsp;&deg;F";
				$tempc = $this->decoded_metar['temperature']['temp_c'] . "&nbsp;&deg;C";
				switch ($prefunits) {
				case 'both_metric':
					$imblock['temp'] = $tempc . " (" . $tempf .")";
					break;
				case 'only_imperial':
					$imblock['temp'] = $tempf;
					break;
				case 'only_metric':
					$imblock['temp'] = $tempc;
					break;
				default:
				case 'both_imperial':
					$imblock['temp'] = $tempf . " (" . $tempc . ")";
					break;
				}
			}

			/*
			* If temperature is rising or falling,
			* show that with an arrow
			*/
			if (isset($this->decoded_pmetar['temperature']['temp_f'])) {
				if ($this->decoded_pmetar['temperature']['temp_f'] != $this->decoded_metar['temperature']['temp_f']) {
					if ($this->decoded_pmetar['temperature']['temp_f'] > $this->decoded_metar['temperature']['temp_f']) {
						$imblock['temp'] .= '&nbsp;' .  _VL_BL_DOWNARROW;
					} else {
						$imblock['temp'] .= '&nbsp;' .  _VL_BL_UPARROW;
					}
				}
			}

			$imblock['dew'] = '';
			if (isset($this->decoded_metar['temperature']['dew_f'])) {
				$dewf = $this->decoded_metar['temperature']['dew_f'] . "&nbsp;&deg;F";
				$dewc = $this->decoded_metar['temperature']['dew_c'] . "&nbsp;&deg;C";
				switch ($prefunits) {
				case 'both_metric':
					$imblock['dew'] = $dewc . " (" . $dewf .")";
					break;
				case 'only_imperial':
					$imblock['dew'] = $dewf;
					break;
				case 'only_metric':
					$imblock['dew'] = $dewc;
					break;
				default:
				case 'both_imperial':
					$imblock['dew'] = $dewf . " (" . $dewc . ")";
					break;
				}
			}

			/*
			* If dewpoint is rising or falling,
			* show that with an arrow
			*/
			if (!empty($imblock['dew'])) {
				if (isset($this->decoded_pmetar['temperature']['dew_f'])) {
					if ($this->decoded_pmetar['temperature']['dew_f'] != $this->decoded_metar['temperature']['dew_f']) {
						if ($this->decoded_pmetar['temperature']['dew_f'] > $this->decoded_metar['temperature']['dew_f']) {
							$imblock['dew'] .= '&nbsp;' .  _VL_BL_DOWNARROW;
						} else {
							$imblock['dew'] .= '&nbsp;' .  _VL_BL_UPARROW;
						}
					}
				}
			}
		}
		$imblock['bar'] = '';
		if (isset($this->decoded_metar['altimeter'])) {
			$bari = $this->decoded_metar['altimeter']['inhg'] . " inHg";
			$barm = $this->decoded_metar['altimeter']['hpa'] . " hPa";
			switch ($prefunits) {
			case 'both_metric':
				$imblock['bar'] = $barm . " (" . $bari .")";
				break;
			case 'only_imperial':
				$imblock['bar'] = $bari;
				break;
			case 'only_metric':
				$imblock['bar'] = $barm;
				break;
			default:
			case 'both_imperial':
				$imblock['bar'] = $bari . " (" . $barm . ")";
				break;
			}
			$imblock['bardir'] = '';
			if (isset($this->decoded_metar['altimeter']['direction'])) {
				if ($this->decoded_metar['altimeter']['direction'] == "PRESFR") {
					$imblock['bardir'] = _VL_BL_PFR;
				} else {
					$imblock['bardir'] = _VL_BL_PRR;
				}
			}
			/*
			* If pressure is not rapidly falling or rapidly rising, but it's still rising or falling,
			* show that with an arrow
			*/
			if (empty($imblock['bardir'])) {
				if (isset($this->decoded_pmetar['altimeter']['inhg'])) {
					if ($this->decoded_pmetar['altimeter']['inhg'] != $this->decoded_metar['altimeter']['inhg']) {
						if ($this->decoded_pmetar['altimeter']['inhg'] > $this->decoded_metar['altimeter']['inhg']) {
							$imblock['bardir'] = _VL_BL_DOWNARROW;
						} else {
							$imblock['bardir'] =  _VL_BL_UPARROW;
						}
					} elseif ($this->decoded_pmetar['time'] != $this->decoded_metar['time']) {
						$imblock['bardir'] = _VL_BL_STEADYARROW;
					}
				}
			}
		}

		$imblock['rel_humidity'] = '';
		if (isset($this->decoded_metar['rel_humidity'])) {
			$relhum = $this->decoded_metar['rel_humidity'];
			if ($relhum) {
				$imblock['rel_humidity'] = $relhum . "&nbsp;%";
			}
			/*
			* Show direction humidity is going, up or down
			*/
			if (isset($this->decoded_pmetar['rel_humidity'])) {
				if ($this->decoded_pmetar['rel_humidity'] != $this->decoded_metar['rel_humidity']) {
					if ($this->decoded_pmetar['rel_humidity'] > $this->decoded_metar['rel_humidity']) {
						$imblock['rel_humidity'] .= '&nbsp;' .  _VL_BL_DOWNARROW;
					} else {
						$imblock['rel_humidity'] .= '&nbsp;' .  _VL_BL_UPARROW;
					}
				}
			}
		}


		$imblock['feels'] = '';
		if (isset($this->decoded_metar['windchill']['windchill_f']) || isset($this->decoded_metar['heatindex']['heatindex_f'])) {
			if (isset($this->decoded_metar['windchill'])) {
				$chillf = $this->decoded_metar['windchill']['windchill_f'] . "&nbsp;&deg;F";
				$chillc = $this->decoded_metar['windchill']['windchill_c'] . "&nbsp;&deg;C";
			}
			elseif (isset($this->decoded_metar['heatindex'])) {
				$heatf = $this->decoded_metar['heatindex']['heatindex_f'] . "&nbsp;&deg;F";
				$heatc = $this->decoded_metar['heatindex']['heatindex_c'] . "&nbsp;&deg;C";
			}
			if (isset($chillf) || isset($heatf)) {
			  if (isset($chillf)) {
  				switch($prefunits) {
	  			case 'both_metric':
  					$imblock['feels'] .= $chillc . " (" . $chillf . ")";
	  				break;
		  		case 'only_imperial':
  					$imblock['feels'] .= $chillf;
	  				break;
  				case 'only_metric':
	  				$imblock['feels'] .= $chillc;
		  			break;
  				default:
	  			case 'both_imperial':
		  			$imblock['feels'] .= $chillf . " (" . $chillc . ")";
			  		break;
  				}
  			} elseif (isset($heatf)) {
  				switch($prefunits) {
	  			case 'both_metric':
  					$imblock['feels'] .= $heatc . " (" . $heatf . ")";
	  				break;
		  		case 'only_imperial':
  					$imblock['feels'] .= $heatf;
	  				break;
  				case 'only_metric':
	  				$imblock['feels'] .= $heatc;
		  			break;
  				default:
	  			case 'both_imperial':
		  			$imblock['feels'] .= $heatf . " (" . $heatc . ")";
			  		break;
  				}
  			}
  			/*
  			* If the windchill or heatindex is rising or falling,show it
  			*/
  			if (isset($this->decoded_pmetar['windchill']['windchill_f'])) {
	  			if ($this->decoded_pmetar['windchill']['windchill_f'] != $this->decoded_metar['windchill']['windchill_f']) {
		  			if ($this->decoded_pmetar['windchill']['windchill_f'] > $this->decoded_metar['windchill']['windchill_f']) {
			  			 $imblock['feels'] .= '&nbsp;' .  _VL_BL_DOWNARROW;
				  	} else {
  						 $imblock['feels'] .= '&nbsp;' .  _VL_BL_UPARROW;
	  				}
		  		}
  			}
	  		if (isset($this->decoded_pmetar['heatindex']['heatindex_f'])) {
  				if ($this->decoded_pmetar['heatindex']['heatindex_f'] != $this->decoded_metar['heatindex']['heatindex_f']) {
	  				if ($this->decoded_pmetar['heatindex']['heatindex_f'] > $this->decoded_metar['heatindex']['heatindex_f']) {
		  				 $imblock['feels'] .= '&nbsp;' .  _VL_BL_DOWNARROW;
			  		} else {
  						 $imblock['feels'] .= '&nbsp;' .  _VL_BL_UPARROW;
	  				}
		  		}
  			}
			}
		}

		// Recent precipitation in the last 3-6 hours

		$imblock['rec_precip_3_6'] = '';
		if (!empty($this->decoded_metar['precipitation']['in_6h']) && $this->decoded_metar['precipitation']['in_6h'] != -1) {
			$recent_precipi = $this->decoded_metar['precipitation']['in_6h'] . " in";
			$recent_precipm = $this->decoded_metar['precipitation']['mm_6h'] . " mm";
			if (!empty($recent_precipi)) {
				switch($prefunits) {
				case 'both_metric':
					$imblock['rec_precip_3_6'] .= $recent_precipm . " (" . $recent_precipi . ")";
					break;
				case 'only_imperial':
					$imblock['rec_precip_3_6'] .= $recent_precipi;
					break;
				case 'only_metric':
					$imblock['rec_precip_3_6'] .= $recent_precipm;
					break;
				default:
				case 'both_imperial':
					$imblock['rec_precip_3_6'] .= $recent_precipi . " (" . $recent_precipm . ")";
					break;
				}
			}
		}

		// Recent precipitation in the last hour

		$imblock['rec_precip'] = '';
		if (!empty($this->decoded_metar['precipitation']['in'])) {
			$recent_precipi = $this->decoded_metar['precipitation']['in'] . " in";
			$recent_precipm = $this->decoded_metar['precipitation']['mm'] . " mm";
			if ($recent_precipi != -1) {
				if (!empty($recent_precipi)) {
					switch($prefunits) {
					case 'both_metric':
						$imblock['rec_precip'] .= $recent_precipm . " (" . $recent_precipi . ")";
						break;
					case 'only_imperial':
						$imblock['rec_precip'] .= $recent_precipi;
						break;
					case 'only_metric':
						$imblock['rec_precip'] .= $recent_precipm;
						break;
					default:
					case 'both_imperial':
						$imblock['rec_precip'] .= $recent_precipi . " (" . $recent_precipm . ")";
						break;
					}
				}
			} else {
				$imblock['rec_precip'] = _VL_BL_TRACE;
			}
		}

		// Precipitation within the past 24 hours - we ignore for now, but why not get it in case we ever use it?

		$imblock['precip_24h'] = '';
		if (!empty($this->decoded_metar['precipitation']['in_24h']) && $this->decoded_metar['precipitation']['in_24h'] != -1) {
			$recent_precipi = $this->decoded_metar['precipitation']['in_24h'] . " in";
			$recent_precipm = $this->decoded_metar['precipitation']['mm_24h'] . " mm";
			if (!empty($recent_precipi)) {
				switch($prefunits) {
				case 'both_metric':
					$imblock['precip_24h'] .= $recent_precipm . " (" . $recent_precipi . ")";
					break;
				case 'only_imperial':
					$imblock['precip_24h'] .= $recent_precipi;
					break;
				case 'only_metric':
					$imblock['precip_24h'] .= $recent_precipm;
					break;
				default:
				case 'both_imperial':
					$imblock['precip_24h'] .= $recent_precipi . " (" . $recent_precipm . ")";
					break;
				}
			}
		}

		// Recent snowfall?

		$imblock['rec_snow'] = '';
		if (!empty($this->decoded_metar['precipitation']['snow_in']) && $this->decoded_metar['precipitation']['snow_in'] != -1) {
			$recent_precipi = $this->decoded_metar['precipitation']['snow_in'] . " in";
			$recent_precipm = $this->decoded_metar['precipitation']['snow_mm'] . " mm";
			if (!empty($recent_precipi)) {
				switch($prefunits) {
				case 'both_metric':
					$imblock['rec_precip'] .= $recent_precipm . " (" . $recent_precipi . ")";
					break;
				case 'only_imperial':
					$imblock['rec_precip'] .= $recent_precipi;
					break;
				case 'only_metric':
					$imblock['rec_precip'] .= $recent_precipm;
					break;
				default:
				case 'both_imperial':
					$imblock['rec_precip'] .= $recent_precipi . " (" . $recent_precipm . ")";
					break;
				}
			}
		}

		$imblock['curr_snow'] = '';
		if (!empty($this->decoded_metar['precipitation']['curr_snow'])) {
			$recent_precipi = $this->decoded_metar['precipitation']['snow_in'] . " in";
			$recent_precipm = $this->decoded_metar['precipitation']['snow_mm'] . " mm";
			if (!empty($recent_precipi)) {
				switch($prefunits) {
				case 'both_metric':
					$imblock['curr_snow'] .= _VL_BL_SNICR;
					break;
				case 'only_imperial':
					$imblock['curr_snow'] .= _VL_BL_SNICR;
					break;
				case 'only_metric':
					$imblock['curr_snow'] .= _VL_BL_SNICR;
					break;
				default:
				case 'both_imperial':
					$imblock['curr_snow'] .= _VL_BL_SNICR;
					break;
				}
			}
		}


		/* Finally we store our interpreted METAR in $this->imblock so
		* that other methods can use it.
		*/
		$this->imblock = $imblock;
		return $imblock;
	}

	function weight_sky($sky1, $sky2, $sky3) {
		$weight = 0;
		$weight1 = 0;
		switch ($sky1) {
		case 'CLR':
		case 'SKC':
			break;
		case 'FEW':
			$weight1 = 1;
			break;
		case 'CB':
			$weight1 = 2;
			break;
		case 'SCT':
			$weight1 = 3;
			break;
		case 'BKN':
			$weight1 = 4;
			break;
		case 'TCU':
			$weight1 = 5;
			break;
		case 'OVC':
			$weight1 = 6;
			break;
		default:
			break;
		}
		$weight2 = 0;
		switch ($sky2) {
		case 'CLR':
		case 'SKC':
			break;
		case 'FEW':
			$weight2 = 1;
			break;
		case 'CB':
			$weight2 = 2;
			break;
		case 'SCT':
			$weight2 = 3;
			break;
		case 'BKN':
			$weight2 = 4;
			break;
		case 'TCU':
			$weight2 = 5;
			break;
		case 'OVC':
			$weight2 = 6;
			break;
		default:
			break;
		}
		$weight3 = 0;
		switch ($sky3) {
		case 'CLR':
		case 'SKC':
			break;
		case 'FEW':
			$weight3 = 1;
			break;
		case 'CB':
			$weight3 = 2;
			break;
		case 'SCT':
			$weight3 = 3;
			break;
		case 'BKN':
			$weight3 = 4;
			break;
		case 'TCU':
			$weight3 = 5;
			break;
		case 'OVC':
			$weight3 = 6;
			break;
		default:
			break;
		}
		$weight = max($weight1,$weight2,$weight3);
		return($weight);
	}

	function get_sky($weight,$type,$night) {
		$sky = '';
		$imagename = '';
		switch ($weight) {
		case 0:
			$sky = 'SKC';
			$imagename = 'SKC';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
			break;
		case 1:
			$sky = 'FEW';
			$imagename = 'FEW';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
			break;
		case 2:
			$sky = 'CB';
			$imagename = 'HI_FEW';
			if ($night) {
				$imagename = 'HI_NFEW';
			}
			break;
		case 3:
			$sky = 'SCT';
			$imagename = 'SCT';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
			break;
		case 4:
			$sky = 'BKN';
			$imagename = 'BKN';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
			break;
		case 5:
			$sky = 'TCU';
			$imagename = 'TCU';
			$weight3 = 5;
			break;
		case 6:
			$sky = 'OVC';
			$imagename = 'OVC';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
			$weight3 = 6;
			break;
		default:
			$sky = '';
			break;
		}
		if ($type == 'image') {
			return($imagename);
		} else {
			return($sky);
		}
	}

	function get_timestring() {
		global $xoopsConfig;
		/*
		Let the server dictate how far from GMT/UTC it is
		Then use that difference to convert the server clock to GMT/UTC
		This way we don't care how the sysadmin set up the server
		*/
		$server_time = time() - (gmmktime(1, 1, 1, 1, 1) - mktime(1, 1, 1, 1, 1));
		$icaogmt_time = $this->decoded_metar['time'] - (gmmktime(1, 1, 1, 1, 1) - mktime(1, 1, 1, 1, 1));
		/*
		echo $server_time;
		echo "<br />";
		echo date("m/d/y g:i a", $server_time);
		echo "<br />";
		echo $icaogmt_time;
		echo "<br />";
		echo date("m/d/y g:i a", $icaogmt_time);
		echo "<br />";
		*/
		$hours_ago = 0;
		$minutes_ago = $server_time - $icaogmt_time;
		$minutes_ago = intval($minutes_ago / 60);
		if ($minutes_ago > 60) {
			$hours_ago = intval($minutes_ago / 60);
			$minutes_ago = $minutes_ago - ($hours_ago * 60);
		}
		$hago = '';
		if ($hours_ago > 1) {
			$hago = $hours_ago . "&nbsp;" . _VL_BL_HOURS . " ";
		}
		elseif ($hours_ago == 1) {
			$hago = $hours_ago . "&nbsp;" . _VL_BL_HOUR . " " ;
		}
		$mago = '';
		if ($minutes_ago > 1) {
			$mago = $minutes_ago . "&nbsp;" . _VL_BL_MINS . " ";
		}
		elseif ($minutes_ago == 1) {
			$mago = $minutes_ago . "&nbsp;" . _VL_BL_MIN . " ";
		}
		$content ="<center><font class=\"sideboxfont\">" . _VL_BL_CONDAO . "<br />" . $hago . $mago .  _VL_BL_AGO ."</font></center>\n";
		return($content);
	}

	function get_vlweather_image() {
		global $xoopsUser, $xoopsConfig;
		$processed_metar_data = $this->decode_metar($this->metar);
		$metar = $processed_metar_data['metar'];
		$parts = explode(' ', $metar);
		$num_parts = count($parts);
		$night = 0;
		$maxcoverage = 0;
		$phenomena1 = '';
		$phenomena2 = '';
		$sky1 = '';
		$sky2 = '';
		$sky3 = '';
		$intensity = '';

		$rawtime = $this->decoded_metar['time'];
		/*
		echo $rawtime;
		echo "<br />";
		echo date("m/d/y g:i a", $rawtime);
		echo "<br />";
		*/
		if ($xoopsUser) {
			$serverdiff = (gmmktime(1, 1, 1, 1, 1) - mktime(1, 1, 1, 1, 1));
			$userdiff = $xoopsUser->timezone() * 3600;
			$totaldiff = $serverdiff - $userdiff;
			$rawtime = $rawtime - $totaldiff;
		} else {
			$serverdiff = (gmmktime(1, 1, 1, 1, 1) - mktime(1, 1, 1, 1, 1));
			//			$serversetdiff = $xoopsConfig['server_TZ'] * 3600;
			$serversetdiff = $this->properties['timeoffset'] * 3600;
			$totaldiff = $serverdiff - $serversetdiff;
			$rawtime = $rawtime - $totaldiff;
		}
		/*
		echo $rawtime;
		echo "<br />";
		echo date("m/d/y g:i a", $rawtime);
		echo "<br />";
		*/
		$hour = date("H", $rawtime);
		$ihour = intval($hour);
		/*
		echo $hour . "<br />";
		*/
		if ($ihour >= 18) {
			$night = 1;
		}
		if ($ihour <= 4) {
			$night = 1;
		}
		for ($i = 0; $i < $num_parts; $i++) {
			$part = $parts[$i];
			//                        echo $part . "<br />";
			if (ereg('RMK|TEMPO|BECMG', $part)) {
				/* The rest of the METAR is either a remark or temporary
				information. We skip the rest of the METAR. */
				break;
			}
			elseif (ereg('([0-9]{2})([0-9]{2})([0-9]{2})Z', $part, $regs)) {}
			elseif (ereg('^(-|\+|VC)?(TS|SH|FZ|BL|DR|MI|BC|PR|RA|DZ|SN|SG|GR|GS|PL|PE|IC|UP|BR|FG|FU|VA|DU|SA|HZ|PY|PO|SQ|FC|SS|DS)+$', $part)) {
				/*
				* Is this the current weather group?
				*/
				// Get the intensity and get rid of it in the $part string
				if (ereg('^(-|\+|VC)(..)*$',$part)) {
					if ($part[0] == '-') {
						$intensity = '-';
						$part = substr($part,1);
					}
					elseif ($part[0] == '+') {
						$intensity = '+';
						$part = substr($part,1);
					}
					elseif ($part[0] . $part[1] == 'VC') {
						$intensity = '';
						$part = substr($part,2);
					}
				}
				// Now, take only the precipitation types that have images.
				// Ignore the others In case more then one exist, take only the
				// first one (highest predominance).
				ereg('(TS|BL|SH|FZ|RA|DZ|SN|SG|GR|GS|PL|PE|IC|BR|FG|FU|FC)(..)*$',$part,$match);
				if (empty($phenomena1) && !empty($match[1])) {
					$phenomena1 = $match[1];
				}
				ereg('(..)(TS|BL|SH|FZ|RA|DZ|SN|SG|GR|GS|PL|PE|IC|BR|FG|FU|FC)(..)*$',$part,$match);
				if (!empty($match[2])) {
					$phenomena2 = $match[2];
				}
			}
			// Now check the cloud coverage. There could be three cloud
			// layers, so check for all of them. Iconize the most covered
			// clouds, thus find the highest cloudcoverage layer, by
			// maximizing the $maxcoverage param
			elseif (empty($sky1) && ereg('(VV|SKC|CLR|FEW|SCT|BKN|OVC|TCU)(...)', $part, $regs)) {
				$sky1 = $regs[1];
			}
			elseif (!empty($sky1) && empty($sky2) && ereg('(VV|SKC|CLR|FEW|SCT|BKN|OVC|TCU)(...)', $part, $regs)) {
				$sky2 = $regs[1];
			}
			elseif (!empty($sky2) && empty($sky3) && ereg('(VV|SKC|CLR|FEW|SCT|BKN|OVC|TCU)(...)', $part, $regs)) {
				$sky3 = $regs[1];
			}
		}

		$imagename = '';
		/* Many cloud conditions can stand on their own, since we have pics for them */
		$weight = $this->weight_sky($sky1, $sky2, $sky3);
		$sky = $this->get_sky($weight,'sky',$night);
		$imagename = $this->get_sky($weight,'image',$night);

		/* If it's fog, we can match it up with a cloud condition */
		if (($phenomena1 == 'FG') || ($phenomena2 == 'FG')) {
			$imagename = 'FG';
			if ($night) {
				$imagename = 'NFG';
			}
			/* SCTFG is only a daytime condition, regardless of the time calculation */
			if ($sky2 == 'SCT') {
				$imagename = 'SCTFG';
			}
			/* BKNFG is only a nighttime condition, etc. */
			if ($sky2 == 'BKN') {
				$imagename = 'NBKNFG';
			}
		}
		
		/* Do other individuals first, they'll get overwritten if it's a combo */
		if (($phenomena1 == 'SH') || ($phenomena2 == 'SH')) {
			$imagename = 'HI_SHWRS';
			if ($night) {
				$imagename = 'HI_NSHWRS';
			}
		}

      /* Dust, no night image */
		if (($phenomena1 == 'DU') || ($phenomena2 == 'DU')) {
			$imagename = 'DU';
		}

      /* Mist, no night image */
		if (($phenomena1 == 'BR') || ($phenomena2 == 'BR')) {
			$imagename = 'BR';
		}

      /* Smoke */
		if (($phenomena1 == 'FU') || ($phenomena2 == 'FU')) {
			$imagename = 'FU';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
		}

      /* Rain */
		if (($phenomena1 == 'RA') || ($phenomena2 == 'RA')) {
			$imagename = 'RA';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
		}

      /* Snow */
		if (($phenomena1 == 'SN') || ($phenomena2 == 'SN')) {
			$imagename = 'SN';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
		}

		/* Ice pellets, hail, small hail, all same image (ice pellets) */
		if (($phenomena1 == 'PE') || ($phenomena1 == 'GR') || ($phenomena1 == 'GS')) {
			$imagename = 'IP';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
		}
		if (($phenomena2 == 'PE') || ($phenomena2 == 'GR') || ($phenomena2 == 'GS')) {
			$imagename = 'IP';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
		}

      /* Extreme cold */
      if ($this->decoded_metar['temperature']['temp_f'] < 0) {
	      $imagename = 'COLD';
   	}
  	   if (isset($this->$decoded_metar['windchill']['windchill_f']) && 
         ($this->$decoded_metar['windchill']['windchill_f'] < 0)) {
  			$imagename = 'COLD';
		}
		
      /* Extreme heat, no night image */
      if (! $night) {
   		if (($phenomena1 == 'HZ') || ($phenomena2 == 'HZ')) {
	   		$imagename = 'HAZY';
		      if ($this->decoded_metar['temperature']['temp_f'] >= 100) {
   		      $imagename = 'HOT';
	   	   }
	   	   if (isset($this->decoded_metar['heatindex']['heatindex_f']) && 
	   			($this->decoded_metar['heatindex']['heatindex_f'] >= 100)) {
	   			$imagename = 'HOT';
   			}
   		}
   	}
   	
   	/* Extreme heat, no night image (otherwise we'd check for NCLR, NSKC, etc.) */
  		if (($imagename == 'CLR') || ($imagename == 'SKC') || ($imagename == 'SCT') || ($imagename == 'FEW')) {
  		   if ($this->decoded_metar['temperature']['temp_f'] >= 100) {
  		      $imagename = 'HOT';
  		   }
     	   if (isset($this->decoded_metar['heatindex']['heatindex_f']) && 
     			($this->decoded_metar['heatindex']['heatindex_f'] >= 100)) {
  	   		$imagename = 'HOT';
  			}
  		}
		
/*  COMBOS   */

		/* Freezing conditions are automatic combos, no night image */
		if (($phenomena1 == 'FZ') || ($phenomena2 == 'FZ')) {
			$imagename = 'FZRA';
		}

      /* Rain showers, no night image */
		if (($phenomena1 == 'SH') && ($phenomena2 == 'RA')) {
			$imagename = 'SHRA';
		}

      /* Mixed freezing rain and rain, no night image */
		if (($phenomena1 == 'FZ') && ($phenomena2 == 'RA')) {
			$imagename = 'FZRARA';
		}

		/* Thunder conditions are automatic combos */
		if (($phenomena1 == 'TS') || ($phenomena2 == 'TS')) {
			$imagename = 'TSRA';
			if ($sky == 'SCT') {
			   $imagename = 'SCTTSRA';
			}
			if ($night) {
				$imagename = 'N' . $imagename;
			}
		}
		
		/* Rain with ice pellets, hail, small hail */
		if (($phenomena1 == 'RA') && ($phenomena2 == 'PE')) {
			$imagename = 'RAIP';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
		}

      /* Mixed freezing rain and snow */
		if (($phenomena1 == 'FZ') && ($phenomena2 == 'SN')) {
			$imagename = 'MIX';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
		}

      /* Rain and snow */
		if (($phenomena1 == 'RA') && ($phenomena2 == 'SN')) {
			$imagename = 'RASN';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
		}

/* Extreme conditions take priority, 
   so we put them last to override 
   any previous choices */

      /* Blizzard */
		if (($intensity == '+') && ($phenomena1 == 'BL') && ($phenomena2 == 'SN')) {
			$imagename = 'BLIZZARD';
		}

      /* Tornado */
		if (($phenomena1 == 'FC') || ($phenomena2 == 'FC')) {
			$imagename = 'TOR';
			if ($night) {
				$imagename = 'N' . $imagename;
			}
		}
		
		$imagefile = strtolower($imagename) . '.jpg';

		/*
		echo "int  : $intensity<br />";
		echo "sky1 : $sky1<br />";
		echo "sky2 : $sky2<br />";
		echo "sky3 : $sky3<br />";
		echo "sky  : $sky<br />";
		echo "phe1 : $phenomena1<br />";
		echo "phe2 : $phenomena2<br />";
		echo $imagefile . "<br />";
		*/
		return($imagefile);
	}
	/**
	* Prints an error-message and halts execution.
	*
	* If the first bit is set in $this->verbosity, this function will
	* print the message, prefixed with the word 'Error:' in bold. If
	* you supply it with the optional arguments $file and $line, these
	* will also be printed.
	*
	* The script will be terminated after the message has been shown.
	*
	* @param  string  The error-message.
	* @param  string  The name of the file where the error occurred.
	* @param  string  The line where the error occurred.
	*/
	function error($msg, $file = '', $line = '') {
		if ($this->verbosity & 1) {
			if (!empty($line)) {
				echo "<p><b>Fatal error:</b> $msg.\n<br>Line <b>$line</b> in file <b>$file</b>.</p>\n";
			} else {
				echo "<p><b>Fatal error:</b> $msg.</p>\n";
			}
			exit;
		}
	}


	/**
	* Issues a warning.
	*
	* If the second bit is set in $this->verbosity, this function will
	* print the message, prefixed with the word 'Warning:' in bold. If
	* you supply it with the optional arguments $file and $line, these
	* will also be printed.
	*
	* Execution of the script continues.
	*
	* @param  string  The warning.
	* @param  string  The name of the file where the error occurred.
	* @param  string  The line where the error occurred.
	*/
	function warning($msg, $file = '', $line = '') {
		if ($this->verbosity & 2) {
			if (!empty($line)) {
				die("<p><b>Warning:</b> $msg.\n<br>Line <b>$line</b> in file <b>$file</b>.</p>\n");
			} else {
				die("<p><b>Warning:</b> $msg.</p>\n");
			}
		}
	}


	/**
	* Prints a message for debugging.
	*
	* The message is only printed if the third bit is set in
	* $this->verbosity. The word 'Debug:' in bold will be prefixed the
	* message.
	*
	* @param  string  The debug-message.
	* @param  string  The name of the file where the message comes from.
	* @param  string  The line where the message comes from.
	*/
	function debug($msg, $file = '', $line = '') {
		if ($this->verbosity & 4) {
			if (!empty($line)) {
				echo "<p><b>Debug:</b> $msg. Line <b>$line</b> in file <b>$file</b>.</p>\n";
			} else {
				echo "<p><b>Debug:</b> $msg.</p>\n";
			}
		}
	}

}
?>
